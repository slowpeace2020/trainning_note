### 1. [List vs Set](#list-vs-set)
### 2. [LinkedList vs ArrayList](#linkedlist-vs-arraylist)
### 3. [What is Map Interface](#what-is-map-interface)
### 4. [How does HashMap work](#how-does-hashmap-work)
### 5. [What is hash collision](#what-is-hash-collision)
### 6. [What is Collections used for](#what-is-collections-used-for)
### 7. [What is immutable class](#what-is-immutable-class)
### 8. [HashTable vs HashMap vs ConcurrentHashmap](#hashtable-vs-hashmap-vs-concurrenthashmap)
### 9. [String vs StringBuilder vs StringBuffer](#string-vs-stringbuilder-vs-stringbuffer)
### 10. [Comparator vs Comparable, when to use which one](#comparator-vs-comparable-when-to-use-which-one)
### 11. [Overriding vs overloading](#overriding-vs-overloading)
### 12. [JRE vs JDK vs JVM](#jre-vs-jdk-vs-jvm)
### 13. [Java 8 basic data types](#java-8-basic-data-types)
### 14. [Primitive type, reference type](#primitive-type-reference-type)
### 15. [What is final keyword](#what-is-final-keyword)
### 16. [Introduce the Java virtual machine stack?](#Introduce-the-Java-virtual-machine-stack?)
### 17. [What is volatile, transient, synchronized](#what-is-volatile-transient-synchronized)
### 18. [throw vs throws](#throw-vs-throws)
### 19. [final vs finally vs finalize](#final-vs-finally-vs-finalize)
### 20. [this vs super](#this-vs-super)
### 21. [abstract class vs interface](#abstract-class-vs-interface)
### 22. [What is the difference between deep copy and shallow copy?](#what-is-the-difference-between-deep-copy-and-shallow-copy)
### 23. [Java modifier scope: public, private, protected, default scope](#java-modifier-scope-public-private-protected-default-scope)
### 24. [What is static scope](#what-is-static-scope)
### 25. [how does classloader work](#how-does-classloader-work)
### 26. [Describe the difference between unchecked and checked exceptions in Java.](#describe-the-difference-between-unchecked-and-checked-exceptions-in-java)
### 27. [What is the difference between finally, final, and finalize in Java?](#what-is-the-difference-between-finally-final-and-finalize-in-java)
### 28. [Define try-with resource. How can you say that it differs from an ordinary try?](#define-try-with-resource-how-can-you-say-that-it-differs-from-an-ordinary-try)
### 29. [Define Runtime Exception. Describe it with the help of an example.](#define-runtime-exception-describe-it-with-the-help-of-an-example)
### 30. [What is the difference between NoClassDefFoundError and ClassNotFoundException in Java](#what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception-in-java)
### 31. [Why should we clean up activities such as I/O resources in the finally block?](#why-should-we-clean-up-activities-such-as-io-resources-in-the-finally-block)
### 32. [Describe OutofMemoryError in exception handling.](#describe-outofmemoryerror-in-exception-handling)
### 33. [What is Generics in Java? What are the advantages of using Generics?](#what-is-generics-in-java-what-are-the-advantages-of-using-generics)
### 34. [How Generics works in Java ? What is type erasure ?](#how-generics-works-in-java--what-is-type-erasure-)
### 35. [What is the difference between List<? extends T>  and  List <? super T>?](#what-is-the-difference-between-list-extends-t--and--list--super-t-)
### 36. [what is Optional class (write a demo code to use ofNullable, orElse, orElseThrow method)](#what-is-optional-class-write-a-demo-code-to-use-ofnullable-orelse-orelsethrow-method)
### 37. [what is functional interface](#what-is-functional-interface)
### 38. [what is default method](#what-is-default-method)
### 39. [what is the difference between Predicate, Supplier, Consumer, Function?](#what-is-the-difference-between-predicate-supplier-consumer-function)
### 40. [write a piece of code to use the  Predicate, Supplier, Consumer, Function interface](#write-a-piece-of-code-to-use-the--Predicate-supplier-consumer-function-interface)
### 41. [what is method reference](#what-is-method-reference)
### 42. [Coding: create a list of students, Student Class has name, age, score three fields.](#coding-create-a-list-of-students-student-class-has-name-age-score-three-fields)
### 43. [Use stream api to find all the students’ name starting with ‘A’](#use-stream-api-to-find-all-the-students-name-starting-with-a)
### 44. [Use stream api to get the sum of all the students score](#use-stream-api-to-get-the-sum-of-all-the-students-score)
### 45. [Use stream api to find all the students whose sore >= 60](#use-stream-api-to-find-all-the-students-whose-sore--60)
### 46. [Use stream api to retrieve all students name](#use-stream-api-to-retrieve-all-students-name)
### 47. [Use stream api to count the frequency of each age](#use-stream-api-to-count-the-frequency-of-each-age)
### 48. [Intermediate operation vs terminal operation](#intermediate-operation-vs-terminal-operation)
### 49. [Thread lifecycle, how does thread transfer from one state to another](#thread-lifecycle-how-does-thread-transfer-from-one-state-to-another)
### 50. [How to create a thread( 4 ways, write code)](#how-to-create-a-thread-4-ways-write-code)
### 51. [How does thread pool work](#how-does-thread-pool-work)
### 52. [What is the potential problem for the newCachedThreadPool and newFixedThreadPool and why](#what-is-the-potential-problem-for-the-newcachedthreadpool-and-newfixedthreadpool-and-why)
### 53. [What is Future](#what-is-future)
### 54. [What is CompletableFuture](#what-is-completablefuture)
### 55. [Future vs CompletableFuture](#future-vs-completablefuture)
### 56. [Lock vs synchronized](#lock-vs-synchronized)
### 57. [What is wait(), notify(), notifyAll(), join()](#what-is-wait-notify-notifyall-join)
### 58. [What is DeadLock](#what-is-deadlock)
### 59. [How to create deadlock(write the code by using ReentrantLock)](#how-to-create-deadlockwrite-the-code-by-using-reentrantlock)
### 60. [How to prevent deadlock and why](#how-to-prevent-deadlock-and-why)
### 61. [CompletableFuture vs Future](#completablefuture-vs-future)
### 62. [CompletableFuture common API](#completablefuture-common-api)
### 63. [Use CompletableFuture to implement the following logic: initial Num = 1, async: num += 10, sync: num *=4, async: consume result and print, exception: if exception, handle it](#use-completablefuture-to-implement-the-following-logic-initial-num--1-async-num--10-sync-num-4-async-consume-result-and-print-exception-if-exception-handle-it)
### 64. [Write the producer and consumer model (by using synchronized keyword)](#write-the-producer-and-consumer-model-by-using-synchronized-keyword)
### 65. [Synchronized normal method vs synchronized static method](#synchronized-normal-method-vs-synchronized-static-method)
### 66. [Write out the optimized Singleton Version and explain each line of code](#write-out-the-optimized-singleton-version-and-explain-each-line-of-code)
### 67. [What are the use cases for singleton](#what-are-the-use-cases-for-singleton)
### 68. [Do research on Factory, Builder, Observer, Decorator, static and dynamic Proxy pattern. what are their use cases, pros and cons](#do-research-on-factory-builder-observer-decorator-static-and-dynamic-proxy-pattern-what-are-their-use-cases-pros-and-cons)
### 69. [What is reflection](#what-is-reflection)
### 70. [How does annotation work in spring](#how-does-annotation-work-in-spring)
### 71. [What are HTTP status codes: 200/ 201/202/ 204/ 307/ 301/ 400/ 401/ 403/ 404/ 500, explain them by your own words](#what-are-http-status-codes-200--201202-204-307-301-400-401-403-404-500-explain-them-by-your-own-words)
### 72. [What is HTTP](#what-is-http)
### 73. [What is get, post, put, delete, patch method](#what-is-get-post-put-delete-patch-method)
### 74. [Post vs patch](#post-vs-patch)
### 75. [Post vs put](#post-vs-put)
### 76. [TCP 3 way handshaking](#tcp-3-way-handshaking)
### 77. [TCP vs UDP](#tcp-vs-udp)
### 78. [What's new in Java 8](#whats-new-in-java-8)
### 79. [What is the difference between JDK, JRE, and JVM?](#difference-between-jdk-jre-and-jvm)
### 80. [How many types of memory areas are allocated by JVM?](#types-of-memory-areas-allocated-by-jvm)
### 81. [What is classloader?](#classloader)
### 82. [What if I write static public void instead of public static void?](#static-public-void-vs-public-static-void)
### 83. [What is the default value of the local variables?](#default-value-of-local-variables)
### 84. [What are the various access specifiers in Java?](#various-access-specifiers-in-java)
### 85. [What is the static variable?](#static-variable)
### 86. [What is the purpose of static methods and variables?](#purpose-of-static-methods-and-variables)
### 87. [What are the restrictions that are applied to the Java static methods?](#restrictions-on-java-static-methods)
### 88. [What is an object?](#what-is-an-object)
### 89. [What is the constructor?](#what-is-the-constructor)
### 90. [Is constructor inherited?](#is-constructor-inherited)
### 91. [Can you make a constructor final?](#can-you-make-a-constructor-final)
### 92. [Can we overload the constructors?](#can-we-overload-the-constructors)
### 93. [Can we make constructors static?](#can-we-make-constructors-static)
### 94. [Can we override the static methods?](#can-we-override-the-static-methods)
### 95. [What if the static modifier is removed from the signature of the main method?](#static-modifier-removed-from-main-method)
### 96. [What is the difference between static (class) method and instance method?](#difference-between-static-method-and-instance-method)
### 97. [Can we make the abstract methods static in Java?](#can-we-make-abstract-methods-static)
### 98. [Can we declare the static variables and methods in an abstract class?](#declaring-static-variables-and-methods-in-abstract-class)
### 99. [What is cross-platformness?](#what-is-cross-platformness)
### 100. [What is bytecode?](#what-is-bytecode)


### 1. List vs Set
Lists maintain order, while sets do not.
Lists allow duplicate elements, while sets do not.
Lists provide access by index, while sets do not.
Lists are typically implemented using arrays or linked lists, while sets are often implemented using hash tables or trees.
Lists are suitable for ordered collections with duplicates, while sets are used for collections with unique elements and where order is not significant.

### 2. LinkedList vs ArrayList
In Java, LinkedList and ArrayList are two common implementations of the List interface, but they have different characteristics:

1. **Underlying Data Structure:**
    - **ArrayList:** Internally backed by an array that dynamically grows as elements are added. It provides fast random access and is efficient for retrieving elements by index.
    - **LinkedList:** Implemented as a doubly linked list, where each element is stored as a separate node with references to the previous and next elements. It is efficient for adding and removing elements from the beginning or end of the list.

2. **Access Time:**
    - **ArrayList:** Provides constant-time access to elements by index (`O(1)`), making it suitable for scenarios where random access to elements is frequent.
    - **LinkedList:** Accessing elements by index in a LinkedList requires traversing the list from the beginning or end, resulting in linear-time access (`O(n)`). It is more efficient for sequential access or operations at the beginning or end of the list.

3. **Insertion and Deletion:**
    - **ArrayList:** Inserting or removing elements in the middle of the list requires shifting subsequent elements, which can be inefficient (`O(n)` time complexity). However, appending elements to the end of the list is fast (`O(1)`).
    - **LinkedList:** Insertion and deletion operations are efficient (`O(1)`) when performed at the beginning or end of the list since they involve updating only the adjacent node references. Insertion and deletion in the middle of the list still require traversing to the target position (`O(n)`).

4. **Memory Overhead:**
    - **ArrayList:** Requires additional memory to accommodate the array capacity, especially if the initial capacity is set high.
    - **LinkedList:** Requires additional memory for storing node references, which can increase memory overhead compared to ArrayList.

5. **Iterating:**
    - **ArrayList:** Iterating over elements using an iterator or enhanced for loop is efficient due to constant-time random access.
    - **LinkedList:** Iterating over elements may be slower compared to ArrayList due to the sequential traversal of nodes.

In summary, ArrayList is generally preferred when random access to elements or frequent access by index is required, while LinkedList is more suitable for scenarios involving frequent insertion or deletion operations at the beginning or end of the list.

### 3. What is Map Interface
The Map interface in Java represents a collection of key-value pairs, where each key is associated with a corresponding value. It is part of the Java Collections Framework and provides methods for storing, retrieving, and manipulating data in a structured manner.

Key characteristics of the Map interface include:

1. **Key-Value Pairs:** A Map consists of entries, each of which contains a key and its corresponding value. The key is used to retrieve the associated value.

2. **Unique Keys:** Each key in a Map must be unique. Duplicate keys are not allowed, and attempting to insert a duplicate key will replace the existing value associated with that key.

3. **Null Keys and Values:** Depending on the implementation, some Map implementations allow null keys and values, while others may not. For example, HashMap allows one null key and multiple null values, while TreeMap does not allow null keys but can have multiple null values.

4. **Ordering:** The order of elements in a Map may or may not be predictable, depending on the specific implementation. For example, HashMap does not guarantee any particular order, while LinkedHashMap maintains insertion order, and TreeMap orders elements based on their natural ordering or a provided comparator.

5. **Key Set:** A Map provides methods to access the set of keys, set of values, or set of key-value pairs (entries) stored in the map.

Common implementations of the Map interface in Java include:

- **HashMap:** Provides constant-time performance for basic operations (add, remove, contains) and does not guarantee the order of elements.
- **TreeMap:** Maintains elements in sorted order based on their natural ordering or a custom comparator.
- **LinkedHashMap:** Preserves the insertion order of elements.
- **HashTable:** Similar to HashMap but is synchronized, making it thread-safe, albeit with lower performance in concurrent environments.
- **ConcurrentHashMap:** Provides thread-safe operations and high concurrency for concurrent access.

Overall, the Map interface in Java offers a versatile way to store and manage key-value pairs, making it widely used in various applications for efficient data organization and retrieval.

### 4. How does HashMap work
HashMap in Java is a widely used implementation of the Map interface. It works based on the principle of hashing, which allows for efficient storage and retrieval of key-value pairs. Here's how HashMap works:

1. **Hashing Mechanism:**
   - When you put a key-value pair into a HashMap using the `put(key, value)` method, the HashMap calculates the hash code of the key using its `hashCode()` method.
   - The hash code is then processed to find the index or bucket in the underlying array where the key-value pair will be stored.
   - The calculated index is obtained by applying a hash function to the hash code. The default implementation in Java performs bitwise operations to ensure a more evenly distributed set of indices.

2. **Handling Collisions:**
   - Since multiple keys can map to the same index due to the limited range of hash codes, collisions can occur.
   - HashMap uses a technique called chaining to handle collisions. In chaining, each bucket in the underlying array is a linked list of entries (key-value pairs) that hash to the same index.
   - When a collision occurs, the new entry is appended to the linked list at the corresponding bucket.

3. **Storing and Retrieving Entries:**
   - When you try to retrieve a value associated with a key using the `get(key)` method, HashMap calculates the hash code of the key, finds the corresponding bucket, and then traverses the linked list (if any) to find the matching key.
   - This process is efficient because the time complexity of finding an element in a linked list is O(1) on average if the list length is small and O(n) in the worst case (when all keys hash to the same index).
   - If the key is found, the associated value is returned. If not found, the `get()` method returns null.

4. **Resizing:**
   - As entries are added to a HashMap, it periodically checks whether the number of entries exceeds a certain threshold based on the load factor (default is 0.75).
   - If the threshold is exceeded, the HashMap is resized by doubling the capacity of the underlying array and rehashing all entries.
   - Resizing is necessary to maintain efficient performance, as it reduces the average length of linked lists (buckets) and minimizes the likelihood of collisions.

Overall, HashMap provides constant-time performance for basic operations such as `put()` and `get()` on average, making it a popular choice for implementing associative arrays and associative lists in Java.

### 5. What is hash collision
A hash collision occurs in a hash table data structure when two different keys hash to the same index or bucket within the underlying array. In other words, when two distinct keys produce the same hash code, a collision happens.

Here's an example to illustrate a hash collision:

1. Suppose we have a hash table with a certain number of buckets, and we use a hash function to map keys to indices in the table.
2. When we insert a key-value pair into the hash table, the hash function calculates the hash code of the key and maps it to an index in the table.
3. However, if another key produces the same hash code or hashes to the same index, a collision occurs.
4. In such cases, the hash table needs a strategy to handle collisions. Common strategies include chaining and open addressing.

Hash collisions are inevitable, especially when dealing with a large number of keys and a limited range of hash codes. The efficiency of handling collisions directly impacts the performance of hash table operations such as insertion, retrieval, and deletion.

To mitigate the impact of collisions and maintain efficient performance, hash table implementations typically employ collision resolution techniques such as chaining (using linked lists or other data structures to store multiple entries at the same index) or open addressing (probing to find an alternative empty slot). These techniques ensure that all key-value pairs are stored and retrievable, even in the presence of collisions.

### 6. What is Collections used for
Collections are used to store groups of objects. Unlike arrays, most collection classes automatically manage the size of the data structure, which means they can grow or shrink dynamically as items are added or removed.

Collections provide methods to manipulate data efficiently. Common operations include adding, removing, and updating elements. Advanced operations like sorting, shuffling, and reversing lists are also supported directly by methods in the Collections class.

Collections provide mechanisms to search for elements and filter data based on certain criteria. For example, a HashSet can be used for fast existence checks, a TreeMap can store sorted data, and a HashMap offers quick retrieval of data based on a key.

Collections can be iterated using iterator patterns provided by the framework. This makes it easy to loop through the elements of a collection, such as a list, set, or map, and perform operations on each element in a controlled way.

Collections simplify the implementation of various data access patterns, such as FIFO (First In, First Out), LIFO (Last In, First Out), and key-value pair mapping. For instance, LinkedList can be used as a queue or a stack, and HashMap provides an associative array functionality.

### 7. What is immutable class
A type of immutable class whose instances cannot be modified after they are created. This means that once an instance of an immutable class is instantiated, its fields or state cannot change in any way. Immutable objects are useful for building reliable and secure applications, as they can simplify concurrency and offer strong guarantees against data alteration.

Final Class: The class itself is often declared final to prevent subclassing, which could potentially add mutable behavior. Final Fields: All fields of the class are usually declared final so they can be assigned only once. No Setter Methods: Immutable classes do not provide "setter" methods that modify fields or objects referred to by fields. Initialization via Constructors: All fields of an immutable object are typically initialized in the constructor. Once set, these fields cannot be changed. Deep Copies for Complex Fields: If an immutable object has fields that refer to mutable objects, such as arrays or collections, these fields should ideally point to copies of these objects, not to the original instances. This practice ensures that the mutable objects cannot be changed from outside the immutable object. Returning Copies Instead of Original References: Any method that returns information about the object's state should return a new copy of the object, rather than a direct reference to a mutable field.

### 8. HashTable vs HashMap vs ConcurrentHashmap
`HashTable`, `HashMap`, and `ConcurrentHashMap` are all implementations of the `Map` interface in Java, but they have differences in terms of thread-safety, performance, and usage scenarios.

1. **HashTable**:
   - **Thread-Safety**: Hashtable is synchronized, meaning it is thread-safe. It ensures that no two threads can modify it at the same time.
   - **Performance**: Hashtable is relatively slower compared to HashMap and ConcurrentHashMap because of the synchronization overhead.
   - **Usage**: Hashtable is considered legacy and has been largely replaced by ConcurrentHashMap for thread-safe operations. However, it may still be used in scenarios where thread safety is required and performance is not a significant concern.

2. **HashMap**:
   - **Thread-Safety**: HashMap is not synchronized, meaning it is not inherently thread-safe. Multiple threads can access and modify it concurrently, but it is not safe to do so without external synchronization.
   - **Performance**: HashMap is faster than Hashtable because it does not incur the overhead of synchronization. However, it is not suitable for concurrent access without proper synchronization.
   - **Usage**: HashMap is widely used in single-threaded or non-concurrent applications where performance is important and thread safety is not a requirement.

3. **ConcurrentHashMap**:
   - **Thread-Safety**: ConcurrentHashMap is designed for concurrent access by multiple threads without external synchronization. It provides better concurrency than Hashtable by using finer-grained locking mechanisms.
   - **Performance**: ConcurrentHashMap provides better performance in multi-threaded scenarios compared to Hashtable, especially under high concurrency, because it allows concurrent read and write operations without blocking.
   - **Usage**: ConcurrentHashMap is recommended for concurrent applications where thread safety and performance are both important. It is commonly used in multi-threaded environments such as server applications and concurrent data processing tasks.

In summary, the choice between Hashtable, HashMap, and ConcurrentHashMap depends on the specific requirements of the application. Use Hashtable for legacy thread-safe scenarios, HashMap for single-threaded or non-concurrent applications, and ConcurrentHashMap for high-performance concurrent applications.

### 9. String vs StringBuilder vs StringBuffer
`String`, `StringBuilder`, and `StringBuffer` are all classes used to manipulate strings in Java, but they have differences in terms of mutability, thread-safety, and performance.

1. **String**:
   - **Mutability**: Strings in Java are immutable, meaning their values cannot be changed after they are created. Any operation that appears to modify a string actually creates a new string object.
   - **Thread-Safety**: Strings are immutable, so they are inherently thread-safe. Multiple threads can access string objects concurrently without the risk of data corruption.
   - **Performance**: String manipulation operations, such as concatenation (`+` operator), are relatively slower because they involve creating new string objects. However, string literals are stored in a string pool, which can improve performance by reusing existing string objects.

2. **StringBuilder**:
   - **Mutability**: StringBuilder is mutable, meaning its value can be changed after it is created. StringBuilder provides methods for appending, inserting, deleting, and replacing characters in a string.
   - **Thread-Safety**: StringBuilder is not thread-safe, meaning it is not synchronized for use in concurrent environments. If StringBuilder is accessed by multiple threads concurrently, external synchronization is required to ensure thread safety.
   - **Performance**: StringBuilder is faster than String for string manipulation operations because it operates directly on the character array buffer, avoiding the overhead of creating new string objects. It is commonly used in scenarios where frequent string modifications are required in a single-threaded environment.

3. **StringBuffer**:
   - **Mutability**: StringBuffer is similar to StringBuilder in that it is mutable and provides methods for string manipulation. However, StringBuffer is synchronized, making it thread-safe for use in concurrent environments.
   - **Thread-Safety**: StringBuffer is thread-safe because it is synchronized. Multiple threads can access and modify a StringBuffer object concurrently without the risk of data corruption.
   - **Performance**: StringBuffer is slower than StringBuilder because of the synchronization overhead. It is recommended for use in scenarios where thread safety is required, such as multi-threaded environments, but performance is less critical.

In summary, use `String` when immutability and thread safety are required, `StringBuilder` when mutability and high performance are needed in a single-threaded environment, and `StringBuffer` when mutability and thread safety are required in a multi-threaded environment.

### 10. Comparator vs Comparable, when to use which one
Comparable is an interface that should be implemented by a class if it has a natural ordering. The class must define a single method, compareTo(Object o), which compares this object with the specified object for order. When a class implements Comparable, it modifies the class itself. Thus, every instance of the class has this one comparison method, and it can be used automatically by sorting methods, such as Collections.sort() or Arrays.sort(), without requiring additional parameters.

Comparator is a functional interface that defines an external comparison strategy. It requires implementing a single method, compare(Object o1, Object o2), which compares its two arguments for order. Use Comparator when you need a specific sort order that is different from the natural ordering of a class, or when you want to sort instances of a class that does not implement

Use Comparable when: You want to enforce a single natural ordering on the objects of your class. The comparison logic can be embedded within the class itself. You control the source code of the class that needs ordering. Use Comparator when: You need multiple different ways to sort types, perhaps in different parts of your application. You need to sort instances of classes that you do not control, and these classes do not implement Comparable. You want to decouple the sorting logic from the class definition to adhere to the single responsibility principle. You are dealing with lambda expressions or method references, which can make Comparator implementations concise and flexible.

### 11. Overriding vs overloading
In programming, "overriding" and "overloading" are two concepts related to functions, but they serve different purposes and are applied in different contexts. Here’s a breakdown of each:

### Overriding

Overriding occurs in object-oriented programming where a method in a subclass or derived class has the same name, return type, and parameters as a method in its superclass or base class. The method in the subclass is said to "override" the method in the superclass. This is used to give a specific implementation to a method that is already provided by its parent class.

**Key points about overriding:**
- It allows a subclass to provide a specific implementation of a method that is already defined in its superclass.
- It is used to change or extend the behavior of a method defined in the base class.
- Overriding methods must have the same signature (name and parameters) and return type as the method in the parent class.
- It supports the concept of polymorphism, where a method call to a overridden method will invoke the implementation of that method defined in the dynamic type of the object.

### Overloading

Overloading, on the other hand, refers to having multiple methods within the same class with the same name but different parameters (different type order or number of parameters). This allows methods to perform similar but slightly different functions, based on the arguments passed to them.

**Key points about overloading:**
- It allows a class to have more than one method having the same name, if their parameter declarations are different.
- Overloading is determined at compile time and is used to increase the readability of the program.
- Overloaded methods can have different return types; what matters is that the parameter lists are different.
- It is also called static polymorphism because the method to be called is determined at compile time.

**Example Comparison:**

Suppose you have a class `Animal` with a method `makeSound()`. In a subclass `Dog`, you might override this method to provide a specific sound like barking. This is overriding.

In contrast, if you have methods in the same class such as `add(int, int)` and `add(float, float)`, this is overloading because the method name is the same but the parameter types are different.

These features help in designing flexible and robust systems, making use of polymorphism to invoke the appropriate method implementations dynamically or statically, as required by the application.
### 12. JRE vs JDK vs JVM
When working with Java, you'll often encounter three main components: JRE (Java Runtime Environment), JDK (Java Development Kit), and JVM (Java Virtual Machine). Understanding the differences and roles of each is essential for any Java developer. Here’s a breakdown of what each component is and how they are related:

### JVM (Java Virtual Machine)

- **What it is**: The JVM is the core of Java's platform-independent capabilities. It's an abstract computing machine that enables a computer to run a Java program. JVM interprets Java bytecode after it has been compiled from source code and provides the runtime environment necessary for executing it.
- **Role**: The JVM is responsible for loading code, verifying code, executing code, and providing the runtime environment. It also handles more sophisticated tasks such as garbage collection and managing system resources.
- **Platform-specific**: There are different JVMs for different operating systems, which means Java can run on various systems (Windows, macOS, Linux, etc.) while the programmers just focus on writing Java code.

### JRE (Java Runtime Environment)

- **What it is**: JRE consists of the JVM and the standard Java class libraries that your Java programs need to run. JRE is essentially a package that provides the environment needed to run Java applications.
- **Role**: It provides libraries, Java Virtual Machine (JVM), and other components to run applications written in Java. It does not contain tools and utilities such as compilers or debuggers for developing applets and applications.
- **Use**: If you only need to run Java programs, but not develop them, you only need to install the JRE.

### JDK (Java Development Kit)

- **What it is**: JDK includes the JRE and the tools you need to develop Java applications and applets. It is the complete kit for developing Java applications.
- **Role**: Along with providing the environment to run Java applications, it also includes development tools such as the Java source compilers, bundling and deployment tools, debuggers, and documentation generators.
- **Use**: If you want to write your own Java programs, then you will need to install the JDK. JDK is a necessity for Java developers.

### Relationship between JVM, JRE, and JDK

1. **JVM** is the engine that provides a runtime environment to drive the Java Code or applications. It's part of both JRE and JDK.
2. **JRE** is the container that provides the library classes and other supporting files that JVM uses at runtime. It includes the JVM itself.
3. **JDK** is the full-featured SDK for Java. It includes JRE which contains JVM, and other tools for developing Java applications.

In summary, to simply run Java applications, you need the JRE. If you are developing Java applications, you need the JDK, which includes everything in the JRE plus development tools. The JVM is the foundational base that allows Java programs to be platform-independent and is integral to both JRE and JDK.
### 13. Java 8 basic data types
Java provides several basic data types, also known as primitive data types. In Java 8, these primitives are fundamental to the language and are designed to hold simple values. Here’s a summary of the eight primitive data types in Java:

### 1. **byte**
- **Description**: The smallest integer data type is `byte`.
- **Size**: 8 bits (1 byte).
- **Range**: -128 to 127.
- **Use**: Useful for saving memory in large arrays where the memory savings are crucial.

### 2. **short**
- **Description**: A larger integer data type than byte.
- **Size**: 16 bits (2 bytes).
- **Range**: -32,768 to 32,767.
- **Use**: Also used to save memory in large arrays of integers.

### 3. **int**
- **Description**: The default integer data type.
- **Size**: 32 bits (4 bytes).
- **Range**: -2^31 to 2^31-1.
- **Use**: Generally used for integer arithmetic operations.

### 4. **long**
- **Description**: A larger integer data type than `int`.
- **Size**: 64 bits (8 bytes).
- **Range**: -2^63 to 2^63-1.
- **Use**: Used when a wider range than `int` is needed.

### 5. **float**
- **Description**: A single-precision 32-bit IEEE 754 floating point.
- **Size**: 32 bits (4 bytes).
- **Range**: Various ranges, precision up to 6-7 decimal digits.
- **Use**: Used to save memory in large arrays of floating point numbers.

### 6. **double**
- **Description**: A double-precision 64-bit IEEE 754 floating point.
- **Size**: 64 bits (8 bytes).
- **Range**: Various ranges, precision up to 15-16 decimal digits.
- **Use**: The default choice for decimal values, more precision than `float`.

### 7. **boolean**
- **Description**: Data type that has only two possible values: `true` and `false`.
- **Size**: Not precisely defined, depends on virtual machine.
- **Range**: `true` or `false`.
- **Use**: Used for simple flags that track true/false conditions.

### 8. **char**
- **Description**: A single 16-bit Unicode character.
- **Size**: 16 bits (2 bytes).
- **Range**: 0 to 65,535 (covers Unicode characters).
- **Use**: Used to store characters.

These data types serve as the building blocks for data manipulation in Java. Understanding their properties and when to use each type is crucial for effective programming and memory management in Java applications.

### 14. Primitive type, reference type
In Java, data types are categorized into two main types: **primitive types** and **reference types**. Each type serves a different purpose and behaves differently in terms of storage, speed, and memory management. Here's an overview of both:

### Primitive Types
Primitive types are the most basic form of data types in Java. They directly contain values and are not objects. Here are some key characteristics:

- **Storage**: Primitive types hold their values directly in the memory where the variable is allocated.
- **Types**: There are eight primitive types: `byte`, `short`, `int`, `long`, `float`, `double`, `boolean`, and `char`.
- **Default Values**: Each primitive type has a default value, for example, `0` for numeric types, `false` for `boolean`, and `\u0000` for `char`.
- **Size**: Each primitive type has a predefined size (e.g., `int` is 32 bits, `double` is 64 bits).
- **Efficiency**: Operations on primitive types are generally faster than on reference types because primitives are stored directly on the stack.

### Reference Types
Reference types, unlike primitive types, refer to objects. Instead of holding the actual data, a reference type stores the address (reference) where the actual data is held in memory. Here are the primary features:

- **Storage**: Reference types store references to their data, which is typically allocated in the heap section of memory.
- **Types**: Reference types include classes, arrays, interfaces, and enums.
- **Default Value**: The default value for reference types is `null`.
- **Memory Management**: Reference types benefit from Java's garbage collection, which helps manage memory by automatically deleting objects that are no longer in use.
- **Usage**: They are used for storing complex objects and collections of data. They can also hold null values, which indicate the absence of data.

### Comparing Primitive and Reference Types
- **Memory Allocation**: Primitives are usually faster to access because they are stored directly in the stack if they are local variables, whereas objects (reference types) are stored in the heap, which requires more overhead to manage.
- **Operations**: Operations on primitive types are faster and more straightforward as they deal directly with the values. Operations on reference types can be more complex due to the indirection of working through references.
- **Default Initialization**: Primitives have default values such as `0` or `false`, depending on the type. Reference types default to `null`, indicating that they do not refer to any object initially.

Understanding the differences between primitive and reference types is crucial for effective Java programming, especially in terms of performance optimization, memory management, and proper design choices when building applications.

### 15. What is final keyword
In Java, the `final` keyword is a modifier used to indicate that a certain feature cannot be changed once it has been assigned. It can be applied to variables, methods, and classes, each serving a different purpose to enforce specific software design principles like immutability and inheritance control. Here’s a breakdown of how `final` can be used in different contexts:

### 1. Final Variables
- **Immutable Value**: When applied to a variable, `final` means that the variable cannot be re-assigned once it has been initialized. This applies to both primitive data types and reference types. For reference types, while the reference itself cannot change to point to a different object, the object itself can still be modified unless the object is inherently immutable (like instances of `String` class).
- **Usage Example**:
  ```java
  final int a = 10;
  // a = 15; // This would cause a compilation error.
  ```

### 2. Final Methods
- **Prevent Overriding**: Applying `final` to a method means that the method cannot be overridden by any subclass. This is useful when you want to keep the implementation of a method the same for all subclasses to ensure consistent behavior across a hierarchy.
- **Usage Example**:
  ```java
  public class Animal {
      public final void breathe() {
          System.out.println("Breathing...");
      }
  }

  // class Dog extends Animal {
  //     public void breathe() { // This would cause a compilation error.
  //         System.out.println("Dog breathing...");
  //     }
  // }
  ```

### 3. Final Classes
- **Prevent Inheritance**: If a class is marked as `final`, it means that the class cannot be subclassed. This is particularly useful when a class is not designed to be extended, or when an immutable behavior is required.
- **Usage Example**:
  ```java
  public final class Constants {
      public static final int MAX_SIZE = 100;
  }

  // class ExtendedConstants extends Constants { // This would cause a compilation error.
  // }
  ```

### General Properties of `final`
- **Enhance Performance**: Using `final` can potentially enable the JVM to perform certain optimizations, such as inlining method calls, because it knows that the method’s behavior cannot change.
- **Semantic Clarity**: Declaring entities as `final` clearly communicates the intentions to other developers that certain behaviors are fixed and not expected to change, improving the readability and maintainability of the code.

Thus, the `final` keyword plays an important role in Java for enforcing certain constraints in the code, making it easier to predict and control the behavior of your programs.

### 16. Introduce the Java virtual machine stack?
The Java Virtual Machine (JVM) stack, often referred to simply as the "stack", is a crucial component of the Java runtime environment. It plays a vital role in the execution of Java programs by managing method invocations and local variables.

Here's a breakdown of its key features:

1. **Method Invocation**: Whenever a method is invoked during the execution of a Java program, the JVM creates a new frame on top of the stack to store information related to the method call. This includes the method's parameters, local variables, and return address.

2. **LIFO Structure**: The JVM stack follows a Last-In-First-Out (LIFO) structure, meaning that the most recently invoked method is always at the top of the stack. When a method completes its execution, its frame is removed from the stack, and control returns to the method that invoked it.

3. **Frame Structure**: Each frame on the JVM stack consists of several components:
   - Local Variable Array: This array stores the method's parameters and local variables.
   - Operand Stack: It is used for intermediate operations during method execution, such as storing operands and results of computations.
   - Frame Data: Additional information required for method execution, such as the method's return address and reference to the runtime constant pool.

4. **Stack Overflow**: Since the stack has a finite size, it is possible to encounter a stack overflow error if the depth of method invocations exceeds the stack's capacity. This typically happens when there is excessive recursion or when deeply nested method calls are made.

5. **Thread-Specific**: Each thread in a Java program has its own JVM stack. This allows concurrent execution of multiple threads without interference.

6. **Managed Memory**: The JVM stack memory is managed by the JVM itself, and it is separate from the heap memory where objects are allocated. This memory management ensures that each thread's stack space is properly allocated and deallocated as needed.

Overall, the JVM stack is a fundamental component of the Java runtime environment, providing a structured mechanism for managing method invocations and local variables during program execution.

### 17. What is volatile, transient, synchronized


### 18. throw vs throws
In Java, `throw` and `throws` are related but serve different purposes:

1. **throw**: `throw` is a keyword used to explicitly throw an exception within a method. When you encounter an error or exceptional condition in your code, you can use `throw` to create an instance of an exception class and throw it. This signals that something unexpected has happened and can be caught by an appropriate exception handler further up the call stack.

   Example:
   ```java
   public void someMethod() {
       if (someCondition) {
           throw new SomeException("An error occurred.");
       }
   }
   ```

2. **throws**: `throws` is a keyword used in method declarations to indicate that the method may throw certain types of exceptions during its execution. It's a way for the method to declare the types of exceptions it can potentially throw, allowing callers of the method to be aware of the exceptions they need to handle or propagate.

   Example:
   ```java
   public void someMethod() throws SomeException {
       // Method implementation that may throw SomeException
   }
   ```

   Here, `someMethod` may throw a `SomeException`, and any code calling `someMethod` should be prepared to handle it (either by catching it or propagating it with its own `throws` clause).

In summary, `throw` is used within a method to explicitly throw an exception, while `throws` is used in a method declaration to indicate the types of exceptions that method might throw.

### 19. final vs finally vs finalize
In Java, `final`, `finally`, and `finalize` are three distinct keywords with different purposes:

1. **final**:
   - The `final` keyword is used to declare constants, make variables immutable, or prevent inheritance or method overriding.
   - When applied to variables, it indicates that the variable's value cannot be changed once initialized. When applied to methods, it indicates that the method cannot be overridden by subclasses. When applied to classes, it indicates that the class cannot be subclassed.
   - For variables, it ensures that the value assigned to them cannot be modified. For methods, it ensures that the behavior of the method cannot be altered by subclasses. For classes, it ensures that the class's behavior and structure remain constant.

   Example:
   ```java
   public class Example {
       final int constantValue = 10;

       final void finalMethod() {
           // Method implementation
       }
   }
   ```

2. **finally**:
   - The `finally` block is used in exception handling to define a block of code that will be executed whether an exception is thrown or not.
   - It is often used in combination with `try` and `catch` blocks to ensure that certain cleanup or resource releasing operations are performed, regardless of whether an exception occurs.
   - Code within the `finally` block will execute even if an exception is thrown, and it will execute after the `try` block or any associated `catch` blocks.

   Example:
   ```java
   try {
       // Code that may throw an exception
   } catch (Exception e) {
       // Exception handling
   } finally {
       // Cleanup code or resource releasing operations
   }
   ```

3. **finalize**:
   - The `finalize` method is a special method provided by the Java runtime system that is called by the garbage collector before an object is garbage collected.
   - It can be overridden in a class to define custom cleanup or resource releasing operations that need to be performed before an object is destroyed.
   - However, it's important to note that the `finalize` method is not guaranteed to be called promptly or at all, and it's generally not recommended to rely on it for critical cleanup tasks. Resource cleanup should ideally be done explicitly using `finally` blocks or other mechanisms.

   Example:
   ```java
   public class Example {
       @Override
       protected void finalize() throws Throwable {
           // Cleanup code or resource releasing operations
           super.finalize();
       }
   }
   ```

In summary, `final` is used to declare constants, immutable variables, or prevent overriding or subclassing; `finally` is used in exception handling to ensure cleanup operations are performed; and `finalize` is a method that can be overridden to define custom cleanup operations before an object is garbage collected.

### 20. this vs super
In Java, `this` and `super` are both keywords used to refer to objects, but they have different meanings and contexts:

1. **this**:
   - `this` is a reference to the current object within an instance method or constructor.
   - It is used to access instance variables and methods of the current object.
   - It can be used to differentiate between instance variables and parameters with the same name within a method or constructor.
   - It can also be used to invoke constructors within other constructors of the same class, using `this()`.

2. **super**:
   - `super` is a reference to the superclass of the current object.
   - It is used to access superclass methods, variables, and constructors from a subclass.
   - It is often used to call superclass constructors explicitly, using `super()` in the subclass constructor.
   - When used in a method, it calls the superclass method with the same signature, even if the subclass has overridden the method.

In summary, `this` refers to the current object, while `super` refers to the superclass of the current object. `this` is used primarily for accessing members of the current object and invoking constructors, while `super` is used for accessing members of the superclass and invoking superclass constructors.

### 21. abstract class vs interface
**Abstract Class**:
1. An abstract class can contain both abstract and non-abstract methods.
2. An abstract class can have constructors, but it cannot be instantiated (i.e., objects cannot be created from it).
3. Subclasses must implement all abstract methods of the abstract class, unless the subclass is also declared abstract.
4. An abstract class can contain member variables, static methods, static members, and constructors.
5. A class can only extend one abstract class.

**Interface**:
1. An interface can only contain abstract methods and constants (static final variables).
2. Methods in an interface are implicitly `public` and `abstract`, and these modifiers can be omitted.
3. Classes implementing an interface must implement all methods defined in the interface.
4. An interface cannot contain member variables, static methods, or constructors.
5. A class can implement multiple interfaces, allowing for multiple inheritance-like behavior.
6. Interfaces can extend other interfaces using the `extends` keyword.

**Similarities**:
1. Both abstract classes and interfaces are abstract and cannot be instantiated; they require subclasses or implementing classes to provide concrete implementations.
2. Both abstract classes and interfaces are used to achieve polymorphism and encapsulation.
3. Both abstract classes and interfaces can define abstract methods, allowing subclasses or implementing classes to provide specific implementations.

**Choosing between them**:
- Use an abstract class when you need to provide some default implementation or shared code.
- Use an interface when you need to define a set of specifications that different classes should implement.
- If a class needs to inherit from another class while also implementing functionality from multiple sources, you can achieve this by extending an abstract class and implementing interfaces.

### 22. What is the difference between deep copy and shallow copy?
In Java, deep copy and shallow copy are two different mechanisms used to duplicate objects, each with distinct behaviors:

1. **Shallow Copy**:
   - Shallow copy creates a new object and copies all the fields of the original object to the new object. However, if the field of the original object is a reference type (e.g., an array or an object), then only the reference to the object is copied, not the object itself. As a result, both the original object and the copied object share the same references to the referenced objects.
   - In other words, shallow copy creates a new object with its own memory space, but the fields that are reference types still point to the same objects as the original object.
   - Shallow copy is a relatively simple and fast operation but may not be sufficient if you need to create a completely independent duplicate of an object.

2. **Deep Copy**:
   - Deep copy creates a new object and recursively copies all the fields of the original object to the new object, including any nested objects or arrays. This means that not only the fields of the original object are copied, but also the objects referenced by those fields are recursively copied.
   - As a result, deep copy creates a completely independent duplicate of the original object, with no shared references to any objects.
   - Deep copy ensures that changes made to the copied object do not affect the original object or any other copied objects.
   - Deep copy is more complex and computationally expensive compared to shallow copy, especially if the object graph being copied is large or contains circular references.

Here's a simple illustration to differentiate between shallow copy and deep copy:

```java
public class Person {
    private String name;
    private Address address;

    // Constructor, getters, and setters...
}

public class Address {
    private String city;

    // Constructor, getters, and setters...
}
```

- Shallow copy of a `Person` object would copy the `name` field and create a new reference to the same `Address` object as the original object.
- Deep copy of a `Person` object would create a new `Person` object with its own `name` field and a deep copy of the `Address` object, including a new `Address` object with its own `city` field.

In summary, shallow copy creates a new object with copied fields, but shared references to referenced objects, while deep copy creates a new object with recursively copied fields, including independent copies of referenced objects.

### 23. Java modifier scope: public, private, protected, default scope
Here's the information presented as a Markdown table:

|           | class | package | subclass  | anywhere |
|-----------|-------|---------|-----------|--------
| public    | ✅    |  ✅     | ✅         | ✅      |
| protected | ✅    |  ✅     | ✅         |        |
| default   | ✅    |  ✅     |           |        |
| private   | ✅    |         |           |        |

### 24. What is static scope
Static scope refers to the visibility or accessibility of variables and methods declared with the `static` keyword in Java.

In Java, when a member (variable or method) of a class is declared as `static`, it means that the member belongs to the class itself rather than to any particular instance of the class. This affects the scope of the member, making it accessible in a specific way:

1. **Class Scope**:
   - Static members have class scope, meaning they can be accessed directly using the class name without needing to create an instance of the class.
   - They are shared among all instances of the class and are initialized only once, typically at the time the class is loaded into memory.
   - Static variables retain their values across different instances of the class, and changes made to them in one instance are visible to all other instances.

Here's an example to illustrate static scope:

```java
public class MyClass {
    public static int staticVariable = 10; // Static variable

    public static void staticMethod() { // Static method
        System.out.println("This is a static method.");
    }

    public void instanceMethod() {
        System.out.println("This is an instance method.");
    }

    public static void main(String[] args) {
        MyClass.staticMethod(); // Accessing static method directly
        System.out.println("Static variable: " + MyClass.staticVariable); // Accessing static variable directly

        MyClass obj1 = new MyClass();
        MyClass obj2 = new MyClass();

        obj1.instanceMethod(); // Accessing instance method using object
        obj2.instanceMethod(); // Accessing instance method using object
    }
}
```

In this example:
- `staticVariable` and `staticMethod()` are declared as static members of the `MyClass` class, and they can be accessed directly using the class name `MyClass`.
- `instanceMethod()` is an instance method, and it can be accessed using instances of the class (`obj1` and `obj2`).

Understanding static scope is important for designing and implementing classes effectively, especially when dealing with shared data or behavior that should be consistent across all instances of the class.

### 25. how does classloader work
In Java, the class loading process is fundamental to the Java Virtual Machine (JVM) runtime environment and is responsible for loading classes into memory as they are referenced by the Java program. Here's an overview of how the class loading process works:

1. **Loading**:
   - The class loading process begins when a Java program references a class for the first time. This could be through the creation of an object, invoking a static method, accessing a static field, or any other operation that requires the class to be loaded.
   - The Java class loader subsystem is responsible for loading classes into memory from various sources, such as the local file system, network, or other sources.

2. **Searching and Locating Classes**:
   - When a class is referenced, the JVM delegates the task of finding and loading the class to the class loaders.
   - The class loaders follow a hierarchical structure, where each class loader delegates the loading of a class to its parent class loader before attempting to load it itself.
   - The Bootstrap Class Loader is the root class loader and is responsible for loading core Java classes from the bootstrap classpath, typically located in the `jre/lib` directory.
   - The Extension Class Loader loads classes from the extension classpath, typically located in the `jre/lib/ext` directory.
   - The Application Class Loader (also known as the System Class Loader) loads classes from the application classpath, which includes user-defined classes and third-party libraries.

3. **Loading Bytecode**:
   - Once a class loader has located the class file, it reads the bytecode from the class file and creates a `Class` object representing the class in memory.
   - The bytecode is then verified to ensure it adheres to the Java language and JVM specifications, including type safety and security checks.

4. **Linking**:
   - After loading the bytecode, the class loader performs three additional steps: verification, preparation, and resolution.
   - Verification checks the bytecode to ensure it is structurally correct and follows the rules of the Java language.
   - Preparation involves allocating memory for class variables and initializing them with default values.
   - Resolution resolves symbolic references to other classes and interfaces within the bytecode, ensuring that all dependencies are satisfied.

5. **Initialization**:
   - Finally, the class loader initializes the class by executing the static initializer (static block) and initializing static fields.
   - This step completes the class loading process, and the class is now ready for use by the Java program.

6. **Caching**:
   - To improve performance, class loaders typically cache loaded classes in memory so that they can be quickly retrieved when needed again.
   - Cached classes are subject to garbage collection like any other objects in memory.

The class loading process in Java is dynamic and flexible, allowing classes to be loaded at runtime as needed, enabling features such as dynamic class loading and reflection. Understanding how class loading works is essential for Java developers, especially when dealing with class loading issues, custom class loaders, and advanced JVM tuning.

### 26. Describe the difference between unchecked and checked exceptions in Java
In Java, exceptions are categorized into two main types: checked exceptions and unchecked exceptions. Here's a breakdown of the differences between them:

1. **Checked Exceptions**:
   - Checked exceptions are exceptions that are checked at compile time by the Java compiler. This means that the compiler ensures that these exceptions are either caught (handled) by the method where they are thrown or declared to be thrown by the method using a `throws` clause.
   - Checked exceptions are subclasses of the `Exception` class (excluding `RuntimeException` and its subclasses).
   - Examples of checked exceptions include `IOException`, `SQLException`, and `ClassNotFoundException`.
   - Checked exceptions typically represent exceptional conditions that are beyond the control of the program, such as I/O errors, database connectivity issues, or class loading problems.
   - It is mandatory to handle or declare checked exceptions, either by wrapping them in try-catch blocks or by declaring them in the method signature using a `throws` clause.

2. **Unchecked Exceptions**:
   - Unchecked exceptions, also known as runtime exceptions, are exceptions that are not checked at compile time by the Java compiler. This means that the compiler does not enforce handling or declaration of these exceptions.
   - Unchecked exceptions are subclasses of the `RuntimeException` class or its subclasses.
   - Examples of unchecked exceptions include `NullPointerException`, `ArrayIndexOutOfBoundsException`, and `ArithmeticException`.
   - Unchecked exceptions typically represent programming errors or logical errors in the code, such as null pointer dereferences, array index out of bounds, or divide by zero errors.
   - Handling unchecked exceptions is optional, and programmers are encouraged to handle them based on their knowledge of the code and the potential risks associated with the exceptions. However, it is not mandatory to handle or declare unchecked exceptions.

In summary, the main difference between checked and unchecked exceptions lies in how they are handled by the Java compiler and the requirement for handling or declaring them in the code. Checked exceptions must be handled or declared, while handling unchecked exceptions is optional.

### 27. What is finally?
`finally` is a keyword in Java used in exception handling to define a block of code that will be executed whether an exception is thrown or not. It is typically used in combination with `try` and `catch` blocks to ensure that certain cleanup or resource-releasing operations are performed, regardless of whether an exception occurs.

The syntax for using `finally` block is as follows:

```java
try {
    // Code that may throw an exception
} catch (ExceptionType e) {
    // Exception handling
} finally {
    // Cleanup code or resource-releasing operations
}
```

Here's how `finally` works:

- The `try` block contains the code that may throw an exception.
- If an exception occurs within the `try` block, the appropriate `catch` block is executed to handle the exception.
- Regardless of whether an exception occurs or not, the `finally` block is always executed after the `try` block or any associated `catch` blocks.
- The `finally` block is useful for releasing resources, closing files or connections, or performing other cleanup operations that need to be done regardless of whether an exception occurs.

Here's an example of using `finally` to close a file regardless of whether an exception occurs:

```java
import java.io.*;

public class FileExample {
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader("example.txt"));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        } finally {
            try {
                if (reader != null) {
                    reader.close(); // Close the file reader
                }
            } catch (IOException e) {
                System.err.println("Error closing file: " + e.getMessage());
            }
        }
    }
}
```

In this example, the `finally` block ensures that the `BufferedReader` is closed even if an exception occurs while reading the file or if the file does not exist. This helps prevent resource leaks and ensures proper cleanup of resources.

### 28. Define try-with resource. How can you say that it differs from an ordinary try?
A try-with-resources statement is a Java language feature introduced in Java 7 that simplifies the handling of resources that need to be closed after being used, such as streams, files, or network connections. It automatically closes the resources at the end of the block, even if an exception occurs, without the need for explicit `finally` blocks.

Here's the syntax of a try-with-resources statement:

```java
try (resource-type resource = initialization) {
    // Code that uses the resource
} catch (ExceptionType e) {
    // Exception handling
}
```

In a try-with-resources statement:

- The `resource-type` is the type of the resource being used, such as `BufferedReader`, `FileInputStream`, or any class that implements the `AutoCloseable` interface.
- The `resource` is the variable that holds the resource. It is declared and initialized within the parentheses after the `try` keyword.
- Inside the try block, you can use the `resource` as needed.
- After the try block completes (either normally or by throwing an exception), the `resource` is automatically closed. The `close()` method of the resource is called implicitly.

Here's an example of using try-with-resources to read from a file:

```java
try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    System.err.println("Error reading file: " + e.getMessage());
}
```

The key difference between try-with-resources and an ordinary try statement with a finally block is the automatic resource management provided by try-with-resources:

1. **Automatic Resource Closure**:
   - In try-with-resources, resources are automatically closed at the end of the try block, regardless of whether an exception occurs.
   - With an ordinary try statement, you need to explicitly close the resources in a finally block, which can lead to more verbose code and potential errors if the close operation itself throws an exception.

2. **Simplified Code**:
   - Try-with-resources reduces boilerplate code and improves code readability by automatically managing the resource lifecycle.
   - It eliminates the need for manual resource cleanup in a finally block, making the code more concise and less error-prone.

In summary, try-with-resources simplifies resource management in Java by automatically closing resources at the end of the try block, providing cleaner and more robust code compared to traditional try-finally blocks.

### 29. Define Runtime Exception. Describe it with the help of an example.
A runtime exception, in the context of programming, refers to an error that occurs while a program is executing, rather than during compilation. These exceptions typically arise due to unforeseen circumstances or incorrect usage of the program.

For example, consider a Java program that attempts to divide an integer by zero:

```java
public class Main {
    public static void main(String[] args) {
        int dividend = 10;
        int divisor = 0;

        // Attempting to divide by zero
        int result = dividend / divisor;

        System.out.println("Result: " + result);
    }
}
```

In this code, when the program executes `dividend / divisor`, it attempts to divide by zero, which is not allowed in mathematics. As a result, a `java.lang.ArithmeticException` is thrown at runtime, halting the program's execution. This is an example of a runtime exception because the error occurs during the program's execution, rather than being caught during compilation.

### 30. What is the difference between NoClassDefFoundError and ClassNotFoundException in Java
`NoClassDefFoundError` and `ClassNotFoundException` are both exceptions in Java related to class loading and classpath issues, but they occur in different contexts.

1. **NoClassDefFoundError**:
   This exception occurs when the Java Virtual Machine (JVM) tries to load a class definition, but it's unable to find the class file at runtime. Unlike `ClassNotFoundException`, this error occurs when the class was available during compilation but is missing at runtime.

   Example:
   ```java
   public class Main {
       public static void main(String[] args) {
           // Attempting to create an instance of MyClass
           MyClass obj = new MyClass();
       }
   }

   class MyClass {} // MyClass exists during compilation

   // During runtime, MyClass.class is missing
   ```

2. **ClassNotFoundException**:
   This exception occurs when the code tries to dynamically load a class at runtime using methods like `Class.forName()` or `ClassLoader.loadClass()`, but the class definition is not found in the classpath.

   Example:
   ```java
   public class Main {
       public static void main(String[] args) {
           try {
               // Attempting to load a class dynamically
               Class.forName("com.example.MyClass");
           } catch (ClassNotFoundException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   If `MyClass` is not found in the classpath during runtime, a `ClassNotFoundException` will be thrown.

In summary, `NoClassDefFoundError` occurs when a class that was available during compilation is missing during runtime, while `ClassNotFoundException` occurs when a class is not found in the classpath during runtime, typically when trying to load it dynamically.

### 31. Why should we clean up activities such as I/O resources in the finally block?
Cleaning up activities, especially resources like I/O (Input/Output) streams, database connections, or network connections, is crucial in programming to ensure proper resource management and prevent resource leaks or potential system instability. Using a `finally` block for resource cleanup is a common practice in languages like Java because it guarantees that the cleanup code will be executed regardless of whether an exception occurs.

Here's why cleaning up activities, especially I/O resources, in the `finally` block is important:

1. **Resource Release**: I/O operations involve external resources like files, network sockets, or database connections. Failing to release these resources properly can lead to resource leaks, where resources are tied up unnecessarily, potentially leading to performance degradation or even resource exhaustion.

2. **Exception Handling**: When performing I/O operations, exceptions can occur due to various reasons such as file not found, disk full, network errors, etc. If an exception occurs before the resource cleanup code is executed, the resources may remain open, leading to resource leaks. Placing the cleanup code in a `finally` block ensures that it will be executed even if an exception occurs, allowing for proper resource cleanup.

3. **Guaranteed Execution**: The `finally` block is guaranteed to be executed, regardless of whether an exception is thrown or not. This ensures that the cleanup code will always run, even if an unexpected error occurs.

4. **Maintaining Program Stability**: Proper resource cleanup helps in maintaining the stability and reliability of the program. Leaked resources can accumulate over time, eventually leading to performance issues or system instability.

Here's an example in Java demonstrating the usage of a `finally` block for cleaning up I/O resources:

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader("example.txt"));
            String line;
            while ((line = reader.readLine()) != null) {
                // Process each line
            }
        } catch (IOException e) {
            // Handle IO exception
            e.printStackTrace();
        } finally {
            // Ensure resource cleanup
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    // Handle close exception
                    e.printStackTrace();
                }
            }
        }
    }
}
```

In this example, the `finally` block ensures that the `BufferedReader` is closed even if an exception occurs during file reading. This prevents resource leaks and ensures proper resource cleanup.

### 32. Describe OutofMemoryError in exception handling.
`OutOfMemoryError` is a type of unchecked exception in Java that occurs when the Java Virtual Machine (JVM) runs out of memory to allocate to new objects. This error typically arises when an application attempts to allocate more memory than the JVM can provide, either due to excessive memory usage by the application or insufficient memory allocated to the JVM itself.

Handling `OutOfMemoryError` can be challenging because it usually indicates a serious problem with the application's memory management or resource usage. However, there are a few strategies to handle or mitigate `OutOfMemoryError`:

1. **Increase JVM Memory**: One approach is to increase the memory allocated to the JVM using the `-Xmx` and `-Xms` options. `-Xmx` sets the maximum heap size, while `-Xms` sets the initial heap size. By allocating more memory to the JVM, you may delay or prevent `OutOfMemoryError`, but it's not a permanent solution.

2. **Optimize Memory Usage**: Analyze your application's memory usage and optimize it to reduce memory consumption. This may involve identifying memory leaks, inefficient data structures, or unnecessary object creation. Tools like profilers can help identify memory hotspots and areas for optimization.

3. **Handle Memory Leaks**: Memory leaks occur when objects are not properly released by the garbage collector, leading to a gradual increase in memory usage over time. Identify and fix memory leaks in your application to prevent `OutOfMemoryError`. Common causes of memory leaks include retaining references to objects longer than necessary or holding references to objects in long-lived data structures.

4. **Graceful Degradation**: Implement graceful degradation mechanisms to handle `OutOfMemoryError` gracefully. For example, you can catch `OutOfMemoryError` exceptions at strategic points in your code and take appropriate action, such as logging the error, releasing non-critical resources, or notifying users.

5. **Avoid Catching**: In most cases, it's not advisable to catch `OutOfMemoryError` explicitly because it usually indicates a severe and unrecoverable condition. It's generally better to let the application crash and restart, rather than attempting to continue execution in an unstable state.

Here's an example of catching and handling `OutOfMemoryError`:

```java
public class Main {
    public static void main(String[] args) {
        try {
            // Code that may cause OutOfMemoryError
            // ...
        } catch (OutOfMemoryError e) {
            // Handle OutOfMemoryError
            System.err.println("Out of memory occurred: " + e.getMessage());
            // Perform cleanup or take appropriate action
            // ...
        }
    }
}
```

However, it's important to note that catching `OutOfMemoryError` should be done with caution, and it's generally preferable to focus on preventing `OutOfMemoryError` through proper memory management and optimization techniques.


### 33. What is Generics in Java? What are the advantages of using Generics?
Generics in Java allow you to create classes, interfaces, and methods that operate on any data type while providing compile-time type safety. They enable you to specify the type of objects that a collection or class can contain or operate on, without committing to a specific data type.

Advantages of using Generics in Java:

1. **Type Safety**: Generics provide compile-time type checking, which helps detect type mismatches and errors at compile time rather than runtime. This reduces the likelihood of ClassCastException or other type-related errors.

2. **Code Reusability**: Generics enable you to write reusable code that can operate on different types without the need for duplication. This promotes cleaner, more modular, and more maintainable code.

3. **Improved Readability**: By specifying the types of objects that a generic class or method can handle, code becomes more self-explanatory and easier to understand. It enhances code readability and reduces the need for explicit type casting.

4. **Performance**: Generics in Java do not incur any performance overhead at runtime because they use type erasure. The compiler removes generic type information during compilation, so there is no runtime penalty for using generics.

5. **Reduced Errors**: Generics help catch errors at compile time, which reduces the likelihood of runtime errors related to type mismatches. This leads to more robust and reliable code.

6. **API Design**: Generics allow you to design APIs that are more flexible and versatile, as they can work with a wide range of data types. This makes APIs more generic and adaptable to different use cases.

7. **Collections Framework**: Generics are extensively used in the Java Collections Framework to create type-safe collections such as ArrayList, HashSet, HashMap, etc. This ensures that collections can only contain objects of a specified type, providing type safety and preventing runtime errors.

Overall, generics in Java offer several benefits including type safety, code reusability, improved readability, and reduced errors, making them a powerful feature for writing efficient and maintainable code.

### 34. How Generics works in Java ? What is type erasure ?
Generics in Java work by allowing you to define classes, interfaces, and methods with type parameters. These type parameters act as placeholders for actual data types and enable you to write code that can work with different types while maintaining type safety. Generics are implemented using a mechanism called type erasure, which is a process performed by the Java compiler to ensure compatibility with older versions of Java and to support backward compatibility.

Here's how generics work in Java:

1. **Type Parameters**: When you define a generic class, interface, or method, you can specify one or more type parameters within angle brackets `< >`. These type parameters represent the types that the generic construct can work with. For example:

    ```java
    public class Box<T> {
        private T value;

        public void setValue(T value) {
            this.value = value;
        }

        public T getValue() {
            return value;
        }
    }
    ```

   Here, `T` is a type parameter representing the type of the value stored in the `Box`.

2. **Parameterized Types**: When you use a generic class, interface, or method, you provide actual type arguments for the type parameters. This is known as parameterizing the generic type. For example:

    ```java
    Box<Integer> integerBox = new Box<>();
    integerBox.setValue(10);
    int value = integerBox.getValue();
    ```

   In this code, `Box<Integer>` is a parameterized type where `Integer` is the actual type argument for the type parameter `T`.

3. **Type Erasure**: Generics in Java are implemented using type erasure, which means that the type information specified by type parameters is removed (erased) during compilation. The compiler replaces all occurrences of the type parameters with their upper bound (or Object if no bound is specified). This process ensures compatibility with older versions of Java, where generics were not supported.

   For example, the `Box<T>` class after type erasure becomes:

    ```java
    public class Box {
        private Object value;

        public void setValue(Object value) {
            this.value = value;
        }

        public Object getValue() {
            return value;
        }
    }
    ```

   Type erasure ensures that generics have no runtime overhead and backward compatibility with older code that does not use generics.

In summary, generics in Java work by allowing you to define generic classes, interfaces, and methods with type parameters, which are replaced with actual types during compilation. Type erasure is the process by which the compiler removes type parameters and replaces them with their upper bounds or Object. This ensures type safety at compile time while maintaining compatibility with older versions of Java.

### 35. What is the difference between List<? extends T>  and  List <? super T>?
In Java generics, `List<? extends T>` and `List<? super T>` are both bounded wildcard types, but they have different meanings and implications:

1. **`List<? extends T>`**:
   - This is known as an upper bounded wildcard. It represents a list of elements of a specific type `T` or any subtype of `T`.
   - With `List<? extends T>`, you can safely read elements from the list, but you cannot add elements to it. This is because the compiler cannot guarantee the exact type of the elements in the list.
   - Example:
     ```java
     List<? extends Number> numbers = new ArrayList<Integer>(); // OK
     Number number = numbers.get(0); // Reading is allowed
     numbers.add(10); // Compilation error, adding is not allowed
     ```

2. **`List<? super T>`**:
   - This is known as a lower bounded wildcard. It represents a list of elements of a specific type `T` or any supertype of `T`.
   - With `List<? super T>`, you can add elements of type `T` or any subtype of `T` to the list, but you cannot safely read elements from it as their exact type is unknown.
   - Example:
     ```java
     List<? super Integer> integers = new ArrayList<Number>(); // OK
     integers.add(10); // Adding is allowed
     Integer value = integers.get(0); // Compilation error, reading is not allowed
     ```

In summary:

- Use `List<? extends T>` when you only need to read elements from the list, and you want to accept any subtype of `T`.
- Use `List<? super T>` when you need to add elements to the list, and you want to accept `T` or any supertype of `T`.

These wildcard types provide flexibility in working with generic types, allowing you to write more generic and reusable code.

### 36. what is Optional class (write a demo code to use ofNullable, orElse, orElseThrow method)
The `Optional` class in Java was introduced in Java 8 as a way to represent an object that may or may not contain a non-null value. It is designed to address the problem of null references and to provide a more expressive and safer way to handle potentially absent values.

Here are some key points about the `Optional` class:

1. **Nullable Object Container**: `Optional` is essentially a container object that may or may not contain a value. It can contain either a non-null value or be empty (`null`).

2. **Avoidance of NullPointerExceptions**: By using `Optional`, you can avoid NullPointerExceptions because you can explicitly check if a value is present before accessing it.

3. **Method Return Types**: `Optional` is often used as a return type for methods that may or may not return a value. Instead of returning null to indicate the absence of a value, these methods return an Optional instance.

4. **Functional Programming**: `Optional` is commonly used in functional programming paradigms, such as with Java Streams, to represent the result of operations that may or may not produce a value.

5. **Immutability**: Instances of `Optional` are immutable, meaning once created, the value inside cannot be changed.

6. **Methods for Value Retrieval**: `Optional` provides methods like `get()` to retrieve the contained value if it is present, `orElse(T other)` to provide a default value if the Optional is empty, `orElseGet(Supplier<? extends T> other)` to lazily provide a default value, and `orElseThrow(Supplier<? extends X> exceptionSupplier)` to throw an exception if the value is not present.

7. **Avoidance of Defensive Programming**: Instead of writing defensive code to check for null references, developers can use `Optional` to clearly express their intent regarding the presence or absence of values.

Here's a basic example of using `Optional`:

```java
import java.util.Optional;

public class Main {
    public static void main(String[] args) {
        // Create an Optional with a non-null value
        Optional<String> optional = Optional.of("Hello");

        // Check if the value is present
        if (optional.isPresent()) {
            // Retrieve and print the value
            System.out.println(optional.get());
        }

        // Create an empty Optional
        Optional<String> emptyOptional = Optional.empty();

        // Provide a default value if the Optional is empty
        String value = emptyOptional.orElse("Default Value");
        System.out.println(value); // Output: Default Value
    }
}
```

In summary, the `Optional` class in Java provides a more robust and expressive way to handle potentially absent values, helping to improve code readability and safety by avoiding null references.

### 37. what is functional interface
In Java, a functional interface is an interface that contains only one abstract method. Functional interfaces are a key concept in Java's functional programming paradigm and are used to enable lambda expressions and method references.

Here are some key points about functional interfaces:

1. **Single Abstract Method (SAM)**: A functional interface must have exactly one abstract method. It can have multiple default methods or static methods, but only one abstract method.

2. **Lambda Expressions**: Functional interfaces are often used with lambda expressions, which allow you to concisely express instances of functional interfaces. Lambda expressions provide a more readable and expressive way to implement the abstract method of a functional interface.

3. **Method References**: Method references provide another way to create instances of functional interfaces. They allow you to refer to methods or constructors without invoking them, which can be particularly useful when the method or constructor matches the signature of the abstract method of the functional interface.

4. **@FunctionalInterface Annotation**: While not strictly necessary, you can use the `@FunctionalInterface` annotation to explicitly mark an interface as a functional interface. This annotation serves as a compiler directive, ensuring that the interface has only one abstract method. It also provides clarity to other developers about the intended use of the interface.

5. **Built-in Functional Interfaces**: Java provides several built-in functional interfaces in the `java.util.function` package, such as `Predicate`, `Function`, `Consumer`, and `Supplier`, among others. These interfaces are commonly used in functional programming scenarios and provide predefined functional signatures for common tasks.

Here's an example of a functional interface and its usage with lambda expressions:

```java
@FunctionalInterface
interface MyFunctionalInterface {
    void myMethod();
}

public class Main {
    public static void main(String[] args) {
        // Using lambda expression to implement MyFunctionalInterface
        MyFunctionalInterface myLambda = () -> System.out.println("Hello from lambda");

        // Calling the abstract method of the functional interface
        myLambda.myMethod(); // Output: Hello from lambda
    }
}
```

In this example, `MyFunctionalInterface` is a functional interface with a single abstract method `myMethod()`. We then use a lambda expression to implement this interface and invoke its abstract method. The lambda expression provides a concise way to define the behavior of `myMethod()` without needing to create a separate class or anonymous inner class.

### 38. What is default method
In Java, a default method is a method defined within an interface that provides a default implementation. Default methods were introduced in Java 8 to allow interface evolution without breaking existing implementations.

Here are some key points about default methods:

1. **Default Implementation**: Default methods provide a way to add new methods to interfaces without forcing all implementing classes to provide an implementation. They allow interface designers to add new methods to existing interfaces without breaking compatibility with existing implementations.

2. **Syntax**: A default method is declared using the `default` keyword followed by the method signature and body. It provides a default implementation that can be overridden by implementing classes if desired.

3. **Multiple Inheritance**: Default methods enable a form of multiple inheritance in Java interfaces. Since a class can implement multiple interfaces, and each interface can have its own default methods, a class can inherit and use multiple default method implementations.

4. **Diamond Problem**: While default methods provide flexibility, they can also introduce the diamond problem when a class implements multiple interfaces with conflicting default method implementations. In such cases, the class must explicitly provide its own implementation, or the compiler will raise an error.

5. **Interface Extension**: Default methods can be used to extend existing interfaces with new methods, allowing for interface evolution without breaking existing code. This is particularly useful for evolving APIs in libraries or frameworks.

6. **Overriding Default Methods**: Implementing classes have the option to override default methods if they need a different behavior. If a class implements multiple interfaces with conflicting default methods, it must explicitly provide an implementation or resolve the conflict.

Here's an example of a default method in an interface:

```java
interface MyInterface {
    // Abstract method
    void abstractMethod();

    // Default method
    default void defaultMethod() {
        System.out.println("Default method implementation");
    }
}

public class MyClass implements MyInterface {
    // Implementing the abstract method
    @Override
    public void abstractMethod() {
        System.out.println("Abstract method implementation");
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.abstractMethod(); // Output: Abstract method implementation
        obj.defaultMethod();  // Output: Default method implementation
    }
}
```

In this example, `MyInterface` contains a default method `defaultMethod()` with a default implementation. The class `MyClass` implements `MyInterface` and provides its own implementation of the abstract method `abstractMethod()`. It also inherits and uses the default implementation of `defaultMethod()` provided by `MyInterface`.

### 39. What is the difference between Predicate, Supplier, Consumer, Function?
`Predicate`, `Supplier`, `Consumer`, and `Function` are all functional interfaces provided in the `java.util.function` package in Java, introduced in Java 8 as part of the functional programming enhancements. Each of these interfaces serves a different purpose and has a different functional signature. Here's a summary of each interface and their differences:

1. **Predicate**:
   - Represents a predicate (boolean-valued function) of one argument.
   - Contains a single abstract method `test(T t)` that takes an argument of type `T` and returns a boolean.
   - Used for evaluating conditions or filtering elements based on a specified criteria.

2. **Supplier**:
   - Represents a supplier of results, which does not take any argument but produces a result.
   - Contains a single abstract method `get()` that returns a result of type `T`.
   - Used for lazily providing or generating values.

3. **Consumer**:
   - Represents an operation that accepts a single input argument and returns no result.
   - Contains a single abstract method `accept(T t)` that takes an argument of type `T` and returns `void`.
   - Used for consuming or processing input data, such as printing, logging, or updating state.

4. **Function**:
   - Represents a function that accepts one argument and produces a result.
   - Contains a single abstract method `apply(T t)` that takes an argument of type `T` and returns a result of type `R`.
   - Used for transforming or mapping input data to output data, such as converting, filtering, or processing.

In summary:

- **Predicate**: Used for evaluating conditions or filtering elements.
- **Supplier**: Used for lazily providing or generating values.
- **Consumer**: Used for consuming or processing input data without returning a result.
- **Function**: Used for transforming or mapping input data to output data.

Here's a simple example demonstrating the usage of each interface:

```java
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        // Predicate: Check if a number is greater than 10
        Predicate<Integer> isGreaterThanTen = num -> num > 10;
        System.out.println(isGreaterThanTen.test(15)); // Output: true

        // Supplier: Generate a random number
        Supplier<Double> randomNumberSupplier = () -> Math.random();
        System.out.println(randomNumberSupplier.get()); // Output: Random double value

        // Consumer: Print a message
        Consumer<String> printMessage = message -> System.out.println("Message: " + message);
        printMessage.accept("Hello, world!"); // Output: Message: Hello, world!

        // Function: Convert a string to uppercase
        Function<String, String> toUpperCase = str -> str.toUpperCase();
        System.out.println(toUpperCase.apply("hello")); // Output: HELLO
    }
}
```

In this example, we demonstrate the usage of each functional interface with lambda expressions. Each lambda expression implements the abstract method of the corresponding interface, performing a specific operation based on the input data.

### 40. What type is used at the inner of String?
At the core of the `String` class in Java is an array of characters (`char[]`) that stores the sequence of characters representing the string. This array holds the individual characters of the string in a sequential order.

Here's a simplified view of the internal structure of a `String` object:

```
String
  |
  +-- char[]
```

This array is used to store the characters of the string and is essential for various string operations such as indexing, substring extraction, and manipulation. However, the `String` class encapsulates this array and provides methods to interact with the string data without directly exposing the array to users of the class.

### 41. what is method reference?
A method reference in Java is a shorthand notation that allows you to refer to a method without invoking it explicitly. It provides a way to pass a method as an argument to another method or to create a lambda expression that calls an existing method.

There are several types of method references:

1. **Reference to a Static Method**: You can reference a static method of a class using the syntax `ClassName::staticMethodName`. For example, `Integer::parseInt` refers to the `parseInt` method of the `Integer` class.

2. **Reference to an Instance Method of an Object**: You can reference an instance method of an object using the syntax `objectReference::instanceMethodName`. For example, `System.out::println` refers to the `println` method of the `System.out` object.

3. **Reference to an Instance Method of a Class Type**: You can reference an instance method of a class type using the syntax `ClassName::instanceMethodName`. For example, `String::length` refers to the `length` method of the `String` class.

4. **Reference to a Constructor**: You can reference a constructor using the syntax `ClassName::new`. For example, `ArrayList::new` refers to the constructor of the `ArrayList` class.

Method references provide a concise and readable way to specify behavior, especially in functional programming contexts such as with streams or lambda expressions. They help in reducing boilerplate code and improving code readability.

### 42. What are the common methods of String class?
The `String` class in Java provides a variety of methods for working with strings. Here are some of the most common methods:

1. **charAt(int index)**: Returns the character at the specified index in the string.

2. **length()**: Returns the length of the string.

3. **substring(int beginIndex)**: Returns a substring of the string starting from the specified index.

4. **substring(int beginIndex, int endIndex)**: Returns a substring of the string starting from the beginIndex and ending at the endIndex - 1.

5. **indexOf(int ch)**: Returns the index of the first occurrence of the specified character in the string.

6. **indexOf(int ch, int fromIndex)**: Returns the index of the first occurrence of the specified character in the string, starting the search at the specified index.

7. **indexOf(String str)**: Returns the index of the first occurrence of the specified substring in the string.

8. **indexOf(String str, int fromIndex)**: Returns the index of the first occurrence of the specified substring in the string, starting the search at the specified index.

9. **lastIndexOf(int ch)**: Returns the index of the last occurrence of the specified character in the string.

10. **lastIndexOf(int ch, int fromIndex)**: Returns the index of the last occurrence of the specified character in the string, starting the search at the specified index.

11. **lastIndexOf(String str)**: Returns the index of the last occurrence of the specified substring in the string.

12. **lastIndexOf(String str, int fromIndex)**: Returns the index of the last occurrence of the specified substring in the string, starting the search at the specified index.

13. **startsWith(String prefix)**: Checks if the string starts with the specified prefix.

14. **endsWith(String suffix)**: Checks if the string ends with the specified suffix.

15. **contains(CharSequence s)**: Checks if the string contains the specified sequence of characters.

16. **isEmpty()**: Checks if the string is empty.

17. **toUpperCase()**: Converts all characters in the string to uppercase.

18. **toLowerCase()**: Converts all characters in the string to lowercase.

19. **trim()**: Removes leading and trailing whitespace from the string.

20. **replace(char oldChar, char newChar)**: Replaces all occurrences of the specified character in the string with the new character.

21. **replace(CharSequence target, CharSequence replacement)**: Replaces all occurrences of the specified target sequence with the replacement sequence.

22. **split(String regex)**: Splits the string into an array of substrings based on the specified regular expression.

23. **join(CharSequence delimiter, CharSequence... elements)**: Joins the elements of an array (or any Iterable) into a single string, using the specified delimiter.

These are just some of the common methods provided by the `String` class in Java. There are many more methods available for various string manipulation and analysis tasks.

### 43. What is string constant pool
The string constant pool is a special area of memory in the Java heap that stores unique instances of string literals. In Java, string literals (e.g., `"hello"`) are stored in the string constant pool to conserve memory and improve performance by reducing the number of duplicate string objects.

Here are some key points about the string constant pool:

1. **Storage of String Literals**: When you create a string literal in Java (e.g., `"hello"`), the JVM checks if an equivalent string already exists in the string constant pool. If it does, the existing string object is reused; otherwise, a new string object is created and added to the pool.

2. **Memory Conservation**: By storing unique string literals in the string constant pool, Java conserves memory by avoiding the creation of duplicate string objects. This is particularly beneficial for applications with a large number of string literals.

3. **String Interning**: The process of adding string literals to the string constant pool is known as string interning. It allows Java to optimize memory usage and string comparison operations.

4. **Compiler Optimization**: In some cases, the Java compiler automatically interns string literals at compile time. This means that identical string literals within the same class or across different classes are automatically stored in the string constant pool.

5. **Implicit Interning**: In addition to string literals, strings created using the `String.intern()` method are also added to the string constant pool. This method returns a canonical representation of the string, either from the pool or by adding it to the pool if it doesn't already exist.

6. **Global Scope**: The string constant pool is shared across all classes and threads within a Java application. This means that any string literal used in the application is stored in the same pool.

7. **Immutable Strings**: Strings stored in the string constant pool are immutable, meaning they cannot be modified after creation. This ensures thread safety and prevents unintended changes to string literals.

Overall, the string constant pool is an important optimization mechanism in Java for managing string literals efficiently and reducing memory overhead. Understanding how string literals are stored and managed in the string constant pool can help developers write more memory-efficient Java code.

### 44. What happens with string concatenation
In Java, string concatenation is the process of combining two or more strings into a single string. String concatenation can be performed using the `+` operator or the `concat()` method of the `String` class.

When you concatenate strings in Java, the following process occurs:

1. **String Conversion**: If the operands of the concatenation operator (`+`) are not strings, they are converted to strings using the `toString()` method of the corresponding objects.

2. **String Allocation**: A new string object is created to store the concatenated result. This new string object is allocated in the Java heap memory.

3. **Concatenation**: The characters of the original strings are copied to the new string object in the order specified by the concatenation operation.

Here's an example:

```java
String str1 = "Hello";
String str2 = "World";
String result = str1 + ", " + str2; // Concatenation using the + operator
```

In this example, the string `"Hello, World"` is created by concatenating the strings `"Hello"`, `", "`, and `"World"`.

It's important to note that because strings are immutable in Java, each concatenation operation results in the creation of a new string object. This can be inefficient for large numbers of concatenations, as it can lead to excessive memory allocation and copying.

To improve performance when concatenating multiple strings, especially in a loop or performance-critical code, consider using the `StringBuilder` class, which provides a mutable buffer for constructing strings efficiently. Here's an example of using `StringBuilder` for concatenation:

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(", ");
sb.append("World");
String result = sb.toString();
```

Using `StringBuilder` can be more efficient than repeated concatenation with the `+` operator, as it avoids the creation of multiple intermediate string objects.

### 45. The difference between new String("abc") and String a = "abc"
The difference between `new String("abc")` and `String a = "abc"` in Java lies in how the strings are created and stored in memory:

1. **`new String("abc")`**:
   - This statement creates a new string object explicitly using the `new` keyword and the `String` constructor.
   - It creates a new string object on the heap memory, even if the string `"abc"` already exists in the string constant pool.
   - If the string `"abc"` is not already in the string constant pool, it will be added to the pool.
   - Using `new String("abc")` is relatively uncommon because it creates redundant string objects and consumes more memory than necessary.

2. **`String a = "abc"`**:
   - This statement creates a string reference `a` that points to the string literal `"abc"` in the string constant pool.
   - If the string `"abc"` does not already exist in the string constant pool, it will be added to the pool.
   - String literals are interned in Java, meaning that duplicate string literals are reused, so `String a = "abc"` will not create a new string object if `"abc"` already exists in the string constant pool.
   - Using string literals directly (e.g., `String a = "abc"`) is the preferred and more efficient way to create strings in Java.

In summary, `new String("abc")` always creates a new string object on the heap, while `String a = "abc"` creates a string reference that may or may not result in a new string object, depending on whether the string literal already exists in the string constant pool.

### 46. What is the difference between Exception and Error?
In Java, `Exception` and `Error` are both subclasses of the `Throwable` class, but they represent different types of problems and are intended to be handled differently:

1. **Exception**:
   - Exceptions represent exceptional conditions that occur during the execution of a program, but they are typically recoverable and can be handled by the application.
   - Exceptions are further divided into two categories: checked exceptions and unchecked exceptions.
      - Checked exceptions: These are exceptions that must be either caught (handled) or declared in the method signature using the `throws` keyword. Examples include `IOException`, `SQLException`, and `ClassNotFoundException`.
      - Unchecked exceptions: These are exceptions that do not need to be caught or declared. They are subclasses of `RuntimeException` or its subclasses. Examples include `NullPointerException`, `ArrayIndexOutOfBoundsException`, and `NumberFormatException`.
   - Exceptions are generally caused by problems that occur within the application's code or environment, such as invalid input, network errors, or file not found.

2. **Error**:
   - Errors represent serious, unrecoverable problems that occur at runtime and are generally caused by external factors beyond the control of the application.
   - Errors are not meant to be caught or handled by the application, as attempting to recover from them may not be feasible or safe.
   - Examples of errors include `OutOfMemoryError`, `StackOverflowError`, and `VirtualMachineError`.
   - Errors typically indicate issues with the Java runtime environment or with system resources, such as running out of memory or encountering a hardware failure.

In summary, exceptions are used to handle exceptional conditions within an application, while errors indicate serious problems that typically cannot be handled programmatically. Exceptions should be caught and handled appropriately, while errors are usually left to be handled by the runtime environment or system administrators.

### 47. Will finally always be executed?
In Java, the `finally` block is used to define a block of code that will be executed regardless of whether an exception is thrown or caught in a `try-catch` block. The `finally` block is optional and follows the `try` block or `try-catch` block.

The `finally` block will always be executed under the following circumstances:

1. **Normal Execution**: If no exception is thrown in the `try` block, the `finally` block will be executed after the `try` block completes.

2. **Exceptional Execution**: If an exception is thrown in the `try` block and caught by a corresponding `catch` block, the `finally` block will be executed after the `catch` block completes.

3. **Uncaught Exception**: If an exception is thrown in the `try` block but not caught by any `catch` block in the same method, the `finally` block will still be executed before the exception propagates up the call stack.

However, there are a few scenarios in which the `finally` block may not be executed:

1. **System.exit()**: If the `try` block contains a call to `System.exit()`, which terminates the Java Virtual Machine, the `finally` block will not be executed.

2. **Infinite Loop or Hang**: If the JVM enters an infinite loop or hangs indefinitely within the `try` block, preventing the completion of the `try` block, the `finally` block will not be executed.

3. **Fatal Errors**: If a fatal error occurs in the JVM, such as an `OutOfMemoryError` or `StackOverflowError`, the `finally` block may not be executed as the JVM may terminate abruptly.

In most cases, however, the `finally` block will be executed, making it a useful construct for performing cleanup actions, releasing resources, or ensuring certain operations are always performed regardless of exceptions.

### 48. Intermediate operation vs terminal operation
In Java Streams, intermediate operations and terminal operations are two types of operations used in stream processing:

1. **Intermediate Operations**:
   - Intermediate operations are operations that are performed on a stream before a terminal operation is executed.
   - These operations transform, filter, or manipulate the elements of the stream and return a new stream as a result.
   - Intermediate operations are lazy, meaning they do not process the entire stream immediately. Instead, they are deferred until a terminal operation is invoked.
   - Examples of intermediate operations include `map`, `filter`, `sorted`, `distinct`, `flatMap`, `peek`, and `limit`.

2. **Terminal Operations**:
   - Terminal operations are operations that are performed on a stream to produce a final result or side effect.
   - Terminal operations trigger the processing of the stream and consume the elements of the stream.
   - Once a terminal operation is invoked, the stream cannot be reused or modified further.
   - Terminal operations are eager, meaning they process the entire stream immediately upon invocation.
   - Examples of terminal operations include `forEach`, `collect`, `reduce`, `count`, `max`, `min`, `anyMatch`, `allMatch`, and `noneMatch`.

Here's a simple example to illustrate the difference between intermediate and terminal operations:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Intermediate operation: map to double each element
Stream<Integer> doubledStream = numbers.stream().map(n -> n * 2);

// Terminal operation: sum all elements
int sum = doubledStream.reduce(0, Integer::sum);
System.out.println("Sum of doubled elements: " + sum);
```

In this example, `map` is an intermediate operation that transforms each element of the stream, doubling its value. This operation returns a new stream. The terminal operation `reduce` is then invoked to sum all elements of the stream, triggering the processing of the stream and producing the final result.

### 49. Thread lifecycle, how does thread transfer from one state to another
In the thread lifecycle, a thread transitions from one state to another based on its execution and external conditions. Here's how a thread typically moves through its lifecycle states:

1. **New:** A thread is in the "New" state when it's created but not yet started using the `start()` method.

2. **Runnable:** After calling the `start()` method, the thread becomes "Runnable." It's ready to run but might not be executing immediately because the scheduler hasn't selected it yet.

3. **Blocked:** The thread can transition to the "Blocked" state when it's waiting for a lock to be released by another thread. This happens when it attempts to access a synchronized block or method already locked by another thread.

4. **Waiting:** Threads can enter the "Waiting" state when they explicitly wait for another thread to notify them or when they wait for a specific period of time using methods like `wait()` or `sleep()`. They remain in this state until they're either notified or the timeout expires.

5. **Timed Waiting:** This state is similar to the "Waiting" state, but it's distinguished by a specific timeout period. Threads enter the "Timed Waiting" state when they call methods like `sleep()` or `join()` with a timeout parameter.

6. **Terminated:** Finally, a thread enters the "Terminated" state when it completes its execution or is explicitly terminated by calling the `stop()` method. Once terminated, the thread cannot be restarted.

Each transition in the thread lifecycle occurs based on specific actions taken by the thread or external events, such as acquiring or releasing locks, waiting for notifications, or completing execution. Understanding these state transitions is crucial for effective multithreaded programming.

### 50. How to create a thread( 4 ways, write code)
1. **extends Thread**:
2. **implements runnable interface**:
3. **implements callable interface and FutureTask**:
4. **Thread pool**

### 51. How does thread pool work
A thread pool is a collection of worker threads that are managed by a thread pool manager. Thread pools are used to efficiently manage and reuse threads to execute multiple tasks concurrently, without the overhead of creating and destroying threads for each task.

Here's how a thread pool typically works:

1. **Initialization**: When a thread pool is created, it initializes a fixed number of worker threads or creates threads on-demand based on configuration parameters such as the minimum and maximum number of threads in the pool.

2. **Task Submission**: Clients submit tasks to the thread pool for execution. Tasks can be submitted either directly as `Runnable` or `Callable` objects or using higher-level constructs like `ExecutorService`.

3. **Task Queue**: Submitted tasks are placed in a task queue, also known as a work queue or task buffer, until a worker thread is available to execute them. The task queue is typically a blocking queue that holds tasks until a worker thread becomes available.

4. **Worker Threads**: Worker threads in the thread pool continuously check the task queue for new tasks. When a worker thread becomes available, it dequeues a task from the task queue and executes it.

5. **Task Execution**: The worker thread executes the task's `run()` method for `Runnable` tasks or calls the `call()` method for `Callable` tasks. The result of the task (if any) is returned to the client or stored for later retrieval.

6. **Thread Reuse**: After executing a task, the worker thread returns to the thread pool and becomes available to execute another task. This allows threads to be reused, reducing the overhead of thread creation and destruction.

7. **Shutdown**: When the thread pool is no longer needed, it can be shut down gracefully. During shutdown, the thread pool manager stops accepting new tasks, waits for currently executing tasks to complete, and then shuts down all worker threads.

By using a thread pool, applications can achieve better performance, scalability, and resource management compared to creating and managing threads manually. Thread pools help prevent resource exhaustion and overload by limiting the number of concurrent threads and queuing tasks during peak loads. They also provide a higher level of abstraction for concurrent programming, simplifying the development of multithreaded applications.

### 52. What is the potential problem for the newCachedThreadPool and newFixedThreadPool and why
Both `newCachedThreadPool()` and `newFixedThreadPool(int n)` are factory methods provided by the `Executors` class in Java to create thread pools with specific characteristics. While these thread pool implementations are useful for various scenarios, they also come with potential problems:

1. **`newCachedThreadPool()`**:

   - **Potential Problem**: Unlimited Thread Creation

   - **Explanation**: `newCachedThreadPool()` creates a thread pool that can dynamically adjust the number of threads based on the workload. It starts with zero threads and creates new threads as needed when tasks are submitted. If a task arrives when all existing threads are busy, a new thread is created. If a thread remains idle for a certain period (60 seconds by default), it is terminated and removed from the pool.

   - **Problem**: While this dynamic scaling behavior can be beneficial for handling bursts of tasks and improving responsiveness, it can also lead to excessive thread creation in scenarios with a high rate of task submission. If tasks are submitted faster than they can be processed, the thread pool may create an excessive number of threads, potentially consuming excessive system resources and leading to performance degradation or even system instability.

2. **`newFixedThreadPool(int n)`**:

   - **Potential Problem**: Resource Exhaustion

   - **Explanation**: `newFixedThreadPool(int n)` creates a thread pool with a fixed number of threads specified by the parameter `n`. Tasks are executed by these `n` threads concurrently. If all threads are busy when a new task is submitted, the task is queued until a thread becomes available.

   - **Problem**: While this fixed-size thread pool ensures a maximum limit on the number of threads and prevents resource exhaustion due to unlimited thread creation, it can lead to resource contention and potential performance degradation if the number of threads is not carefully chosen. If the fixed number of threads is too high, it may consume excessive system resources, such as CPU and memory, leading to contention and inefficient use of resources. Conversely, if the number of threads is too low, it may result in task queuing and increased response time, especially under heavy load conditions.

To mitigate these potential problems, it's essential to carefully choose the appropriate thread pool configuration based on the specific requirements and characteristics of the application, such as the expected workload, concurrency level, resource availability, and performance objectives. Additionally, monitoring and tuning the thread pool configuration during runtime can help optimize performance and resource utilization.

### 53. What is Future
In Java, `Future` is an interface in the `java.util.concurrent` package that represents the result of an asynchronous computation. It provides a way to retrieve the result of an asynchronous operation or to cancel the operation if desired.

Here are some key points about `Future`:

1. **Asynchronous Computation**: `Future` is commonly used in scenarios where a task is executed asynchronously, meaning that it runs independently of the main program flow and may take some time to complete.

2. **Result Retrieval**: The `Future` interface defines methods for retrieving the result of the asynchronous computation. The `get()` method is used to obtain the result of the computation once it is available. This method blocks until the result is available or until a specified timeout period expires.

3. **Cancellation**: The `Future` interface also provides a `cancel()` method to cancel the asynchronous computation if it has not already completed. This method attempts to cancel the execution of the task, returning `true` if the cancellation was successful or `false` otherwise.

4. **Completion Status**: The `isDone()` method can be used to check whether the asynchronous computation has completed. It returns `true` if the computation has completed, either normally or by cancellation, or `false` otherwise.

5. **Exception Handling**: If the asynchronous computation encounters an exception, the `get()` method will throw an `ExecutionException` when attempting to retrieve the result. It's essential to handle exceptions appropriately when using `Future` to avoid propagating exceptions up to the caller.

`Future` is often used in conjunction with `ExecutorService` and `ThreadPoolExecutor` to execute tasks asynchronously and retrieve their results. It provides a convenient and flexible way to perform parallel and concurrent programming in Java, enabling tasks to run concurrently without blocking the main program flow. Additionally, `Future` serves as a building block for more advanced concurrency features such as `CompletableFuture` and asynchronous programming models in Java.

### 54. What is CompletableFuture
`CompletableFuture` is a class introduced in Java 8 as part of the `java.util.concurrent` package. It provides a powerful and flexible way to work with asynchronous computations and handle their results, building upon the concepts of the `Future` interface.

Here are some key features of `CompletableFuture`:

1. **Asynchronous Computation**: Like `Future`, `CompletableFuture` represents the result of an asynchronous computation or task. However, it offers more flexibility and control over the asynchronous execution process.

2. **Completion Actions**: `CompletableFuture` allows you to define completion actions to be executed when the asynchronous computation completes, either normally or exceptionally. These actions can be specified using methods such as `thenAccept`, `thenApply`, `thenCompose`, `thenCombine`, etc.

3. **Chaining**: `CompletableFuture` supports chaining of asynchronous computations, where the output of one computation can be used as input to another computation. This allows for building complex asynchronous workflows and pipelines.

4. **Exception Handling**: `CompletableFuture` provides robust exception handling mechanisms, allowing you to handle exceptions thrown during the execution of asynchronous tasks and propagate them through the completion chain.

5. **Combining and Combining**: `CompletableFuture` offers methods for combining multiple `CompletableFuture` instances, such as `thenCombine`, `thenAcceptBoth`, `thenCompose`, etc., enabling parallel and concurrent execution of independent tasks.

6. **Timeouts and Cancelling**: `CompletableFuture` supports specifying timeouts for asynchronous computations using methods like `orTimeout` and `completeOnTimeout`, as well as cancelling the computation using the `cancel` method.

7. **Async Execution Control**: `CompletableFuture` provides control over the execution of asynchronous tasks, allowing you to specify whether tasks should be executed asynchronously or synchronously, and which executor to use for execution.

`CompletableFuture` is highly versatile and can be used in various scenarios, such as parallel processing, asynchronous I/O operations, reactive programming, and more. It offers a rich set of methods and features for building responsive and efficient concurrent applications in Java.

### 55. Future vs CompletableFuture
`Future` and `CompletableFuture` are both used to represent the result of asynchronous computations in Java, but they differ in their capabilities and features. Here's a comparison between the two:

#### Future:

1. **Limited Functionality:** The `Future` interface, introduced in Java 5, provides basic support for asynchronous computation result retrieval.

2. **Blocking Get:** The `get()` method of `Future` blocks until the result of the computation is available. If the computation is not yet complete, the calling thread will be blocked until the result is ready.

3. **No Exception Handling:** `Future` does not provide built-in support for handling exceptions that occur during computation. If an exception occurs, it must be handled explicitly by the calling code.

4. **No Completion Actions:** `Future` does not support attaching completion actions to be executed when the computation is complete.

#### CompletableFuture:

1. **Enhanced Functionality:** `CompletableFuture`, introduced in Java 8, extends the capabilities of `Future` by providing a more comprehensive set of features for asynchronous programming.

2. **Non-blocking Get:** Like `Future`, `CompletableFuture` offers a `get()` method to retrieve the result of the computation. However, it also provides non-blocking methods like `join()` to obtain the result without blocking.

3. **Exception Handling:** `CompletableFuture` offers built-in support for exception handling through methods like `exceptionally` and `handle`. Developers can specify how to handle exceptions that occur during computation.

4. **Completion Actions:** Unlike `Future`, `CompletableFuture` allows you to attach completion actions using methods like `thenApply`, `thenAccept`, and `thenRun`. These actions are executed asynchronously when the computation is complete, enabling fluent chaining of asynchronous operations.

5. **Combining and Chaining:** `CompletableFuture` supports combining and chaining multiple asynchronous computations using methods like `thenCompose`, `thenCombine`, and `thenAcceptBoth`.

6. **Timeouts and Cancellation:** `CompletableFuture` provides methods for setting timeouts on asynchronous computations and cancelling them if they take too long to complete.

7. **Stream Integration:** `CompletableFuture` integrates seamlessly with Java Streams API, allowing asynchronous computations to be combined with stream processing operations.

In summary, while both `Future` and `CompletableFuture` serve similar purposes, `CompletableFuture` offers more advanced features and capabilities for asynchronous programming, making it a preferred choice for modern Java applications. It provides enhanced control, exception handling, and composability, enabling developers to express complex asynchronous workflows more concisely and effectively.


### 56. Lock vs synchronized
Here's a comparison of `Lock` and `synchronized` in Java:

| Feature          | `Lock`                                    | `synchronized`                        |
|------------------|-------------------------------------------|---------------------------------------|
| Interface        | Interface provided by the `java.util.concurrent.locks` package. | Keyword provided by the Java language. |
| Implementation   | ReentrantLock, ReentrantReadWriteLock, etc. | Intrinsic lock provided by Java runtime. |
| Lock Acquisition | Acquired and released explicitly using `lock()` and `unlock()` methods. | Automatically acquired and released based on block scope. |
| Fairness         | Can be configured for fairness using `ReentrantLock(boolean fair)` constructor. | Fairness not configurable, uses built-in fairness policy. |
| Interruptible    | Supports interruptible lock acquisition using `lockInterruptibly()` method. | Not directly interruptible, may cause thread to block indefinitely. |
| Condition Support | Supports conditions for inter-thread communication using `newCondition()` method. | Not directly supported, may use `Object.wait()` and `Object.notify()` for similar functionality. |
| Multiple Locks   | Allows acquiring multiple locks in a non-nested fashion. | Supports nested locking, automatically reentrant. |
| Flexibility      | Provides more flexibility and control over locking behavior. | Simpler and more convenient for basic synchronization needs. |
| Performance      | Generally provides better performance, especially in high-contention scenarios. | May introduce more overhead due to built-in JVM optimizations. |

In summary, `Lock` provides more flexibility and control over locking behavior, allowing for features such as fairness, interruptibility, multiple locks, and condition support. On the other hand, `synchronized` is simpler and more convenient for basic synchronization needs but may have limitations in certain scenarios. The choice between `Lock` and `synchronized` depends on the specific requirements and complexity of the synchronization logic in your application.

### 57. What is wait(), notify(), notifyAll(), join()
1. **wait():**
   - `wait()` is a method defined in the `Object` class in Java.
   - It is used for inter-thread communication and synchronization.
   - When a thread calls `wait()` on an object, it releases the lock on that object and waits until another thread notifies it using the `notify()` or `notifyAll()` method.
   - `wait()` must be called from within a synchronized block or method.

2. **notify():**
   - `notify()` is a method defined in the `Object` class in Java.
   - It is used to wake up a single thread that is waiting on the object's monitor.
   - When a thread calls `notify()` on an object, it wakes up one of the threads that are waiting on that object's monitor.
   - The choice of which thread to wake up is arbitrary and depends on the JVM implementation.

3. **notifyAll():**
   - `notifyAll()` is a method defined in the `Object` class in Java.
   - It is used to wake up all threads that are waiting on the object's monitor.
   - When a thread calls `notifyAll()` on an object, all threads that are waiting on that object's monitor are notified and can attempt to acquire the lock.

4. **join():**
   - `join()` is a method defined in the `Thread` class in Java.
   - It is used to wait for a thread to complete its execution before continuing with the current thread's execution.
   - When a thread calls `join()` on another thread, it waits until the other thread completes execution or the specified timeout period elapses.
   - `join()` is often used to coordinate the execution of multiple threads, allowing one thread to wait for the completion of another thread's task before proceeding.

These methods are fundamental for implementing synchronization, communication, and coordination between threads in Java programs. They enable developers to control the execution flow and ensure proper synchronization and cooperation between concurrent threads.

### 58. What is DeadLock
A deadlock in Java occurs when two or more threads are blocked indefinitely, each waiting for the other to release a resource that they need in order to proceed. As a result, the threads end up waiting indefinitely, and the program becomes unresponsive. Deadlocks are a common problem in multi-threaded programming and can be difficult to detect and resolve.

Deadlocks typically occur when the following conditions are met:

1. **Mutual Exclusion:** Each thread holds a resource (such as a lock) that is required by another thread in order to proceed. These resources cannot be shared simultaneously between threads.

2. **Hold and Wait:** Each thread holds at least one resource and is waiting to acquire additional resources that are held by other threads.

3. **No Preemption:** Resources cannot be forcibly taken away from a thread; they must be released voluntarily by the thread holding them.

4. **Circular Wait:** There exists a circular chain of two or more threads, where each thread is waiting for a resource that is held by the next thread in the chain.

When these conditions are met, a deadlock can occur because none of the threads can make progress—they are all waiting for resources that are held by other threads, creating a circular dependency.

Detecting and resolving deadlocks can be challenging, as they often involve complex interactions between multiple threads and resources. Common techniques for preventing deadlocks include:

- Avoiding circular dependencies by acquiring resources in a consistent order.
- Using timeouts or other mechanisms to break deadlock situations.
- Minimizing the use of locks and synchronization where possible.
- Using higher-level concurrency constructs that handle resource management automatically, such as `java.util.concurrent` classes.

Overall, deadlocks are a serious issue in multi-threaded programming and require careful design and attention to avoid.

### 59. How to create deadlock(write the code by using ReentrantLock)
### 60. How to prevent deadlock and why
Preventing deadlocks involves designing your concurrent code in such a way that the conditions necessary for a deadlock to occur are avoided. Here are some strategies for preventing deadlocks:

1. **Lock Ordering:**
   - Always acquire locks in a fixed and predefined order. By establishing a consistent lock acquisition order across all threads, you can prevent circular dependencies and reduce the likelihood of deadlocks.
   - For example, if Thread A always acquires Lock 1 before Lock 2, and Thread B always acquires Lock 2 before Lock 1, the potential for a deadlock is eliminated.

2. **Lock Timeout:**
   - Use lock timeouts to avoid indefinite blocking. Instead of waiting indefinitely for a lock to become available, threads can wait for a specified period of time before timing out.
   - If a lock cannot be acquired within the timeout period, the thread can release any acquired locks and retry later, preventing potential deadlocks.

3. **Lock Hierarchy:**
   - Establish a hierarchy of locks and ensure that locks are acquired in a hierarchical order. This helps prevent nested locks from being acquired out of order, which can lead to deadlocks.
   - For example, if Lock B is always acquired within the scope of Lock A, threads should acquire Lock A before attempting to acquire Lock B.

4. **Avoid Nested Locks:**
   - Minimize the use of nested locks, where one lock is acquired while holding another lock. Nested locks increase the complexity of lock acquisition and make it more difficult to reason about potential deadlocks.
   - Instead, design your code to use coarse-grained locks that cover larger sections of code, reducing the need for nested locking.

5. **Deadlock Detection and Recovery:**
   - Implement deadlock detection mechanisms to identify and recover from deadlock situations when they occur. This can involve periodically checking for deadlock conditions and taking appropriate action, such as releasing locks and retrying.

Preventing deadlocks is essential for maintaining the stability and reliability of concurrent applications. By carefully designing your code to follow these principles, you can minimize the risk of deadlocks and ensure smooth execution of concurrent operations.


### 61. [CompletableFuture vs Future](#completablefuture-vs-future)
### 62. CompletableFuture common API
The `CompletableFuture` class in Java provides several common APIs for working with asynchronous computations. Some of the common methods and APIs provided by `CompletableFuture` include:

1. **Creation Methods**:
   - `CompletableFuture.runAsync(Runnable runnable)`: Executes the given `Runnable` asynchronously and returns a `CompletableFuture<Void>` that is completed when the `Runnable` completes.
   - `CompletableFuture.supplyAsync(Supplier<U> supplier)`: Executes the given `Supplier` asynchronously and returns a `CompletableFuture<U>` that is completed with the result of the `Supplier`.

2. **Completion Stage Methods**:
   - `thenApply(Function<? super T,? extends U> fn)`: Applies the given function to the result of the current `CompletableFuture` and returns a new `CompletableFuture` with the result of the function applied.
   - `thenAccept(Consumer<? super T> action)`: Performs the given action with the result of the current `CompletableFuture` and returns a new `CompletableFuture<Void>` that is completed when the action completes.
   - `thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)`: Combines the results of the current `CompletableFuture` and another `CompletionStage` using the given function.

3. **Error Handling**:
   - `exceptionally(Function<Throwable,? extends T> fn)`: Returns a new `CompletableFuture` that is completed with the result of the given function if the current `CompletableFuture` completes exceptionally.
   - `handle(BiFunction<? super T, Throwable, ? extends U> fn)`: Combines the result of the current `CompletableFuture` and any exception that occurred during its computation using the given function.

4. **Combining and Chaining**:
   - `thenCompose(Function<? super T, ? extends CompletionStage<U>> fn)`: Applies the given function to the result of the current `CompletableFuture` and returns a new `CompletableFuture` that represents the result of the function applied.
   - `thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)`: Combines the results of the current `CompletableFuture` and another `CompletionStage` asynchronously using the given function.

5. **Waiting for Completion**:
   - `join()`: Waits for the completion of the `CompletableFuture` and returns its result, throwing an unchecked exception if the computation completed exceptionally.

These are some of the common APIs provided by `CompletableFuture` for asynchronous programming in Java. They allow for composing, combining, and handling asynchronous computations in a flexible and expressive manner.\



### 63. [Use CompletableFuture to implement the following logic: initial Num = 1, async: num += 10, sync: num *=4, async: consume result and print, exception: if exception, handle it](#use-completablefuture-to-implement-the-following-logic-initial-num--1-async-num--10-sync-num-4-async-consume-result-and-print-exception-if-exception-handle-it)
### 64. [Write the producer and consumer model (by using synchronized keyword)](#write-the-producer-and-consumer-model-by-using-synchronized-keyword)
### 65. Synchronized normal method vs synchronized static method
In Java, both synchronized normal methods and synchronized static methods are used to achieve thread safety by preventing multiple threads from accessing critical sections of code concurrently. However, there are some differences between them:

1. **Lock Acquisition**:
   - Synchronized normal methods: When a synchronized instance method is invoked, the lock associated with the object instance (`this`) is acquired. Therefore, if multiple threads are invoking synchronized instance methods on different object instances, they can execute concurrently because they lock on different objects.
   - Synchronized static methods: When a synchronized static method is invoked, the lock acquired is on the class object representing the class itself (i.e., `ClassName.class`). Therefore, only one thread can execute any synchronized static method of the class at a time, regardless of which instance or object invoked the method.

2. **Instance vs Class Level Lock**:
   - Synchronized normal methods: Use instance-level lock (lock on `this` object).
   - Synchronized static methods: Use class-level lock (lock on `Class.class` object).

3. **Visibility and Inheritance**:
   - Synchronized normal methods: Each object instance has its own monitor lock, so synchronization is inherited by subclasses.
   - Synchronized static methods: The lock is acquired on the class object, which is shared among all instances and subclasses. Therefore, synchronization is also inherited by subclasses.

4. **Accessing Non-static Members**:
   - Synchronized normal methods: Can access both static and non-static members of the class.
   - Synchronized static methods: Cannot directly access non-static (instance) members of the class because they operate at the class level.

Here's an example illustrating the use of synchronized normal method and synchronized static method:

```java
public class SynchronizedExample {

    private static int staticCounter = 0;
    private int instanceCounter = 0;

    // Synchronized normal method (instance-level lock)
    public synchronized void incrementInstanceCounter() {
        instanceCounter++;
    }

    // Synchronized static method (class-level lock)
    public static synchronized void incrementStaticCounter() {
        staticCounter++;
    }
}
```

In this example, `incrementInstanceCounter` is a synchronized normal method, and `incrementStaticCounter` is a synchronized static method. Each method ensures that only one thread can execute it at a time based on the type of lock it acquires.

### 66. [Write out the optimized Singleton Version and explain each line of code](#write-out-the-optimized-singleton-version-and-explain-each-line-of-code)
### 67. What are the use cases for singleton
Singleton pattern is used when we need to ensure that a class has only one instance and provides a global point of access to that instance. Some common use cases for singleton pattern include:

1. **Resource Management**:
   - When there is a need to manage a shared resource, such as a database connection pool, thread pool, cache, configuration settings, or logging mechanism, singleton pattern ensures that only one instance of the resource manager is created and accessed throughout the application.

2. **Factory Classes**:
   - Singleton pattern is often used in factory classes to ensure that only one factory instance is responsible for creating objects of a certain type. This helps maintain consistency and control over the creation process.

3. **State Management**:
   - In scenarios where maintaining a single state across the application is critical, singleton pattern can be used to encapsulate the state and provide access to it globally. This is common in applications dealing with user sessions, preferences, or application settings.

4. **Logging**:
   - Singleton pattern is commonly used for logging frameworks to ensure that there is only one instance of the logger throughout the application. This allows centralized logging control and configuration.

5. **Caching**:
   - Singleton pattern can be used to implement caching mechanisms where a single cache instance is shared across the application to store frequently accessed data and improve performance.

6. **Driver Objects**:
   - In cases where a single instance of a driver object is required to interact with a hardware device or external system, singleton pattern can ensure that only one instance of the driver object is created and managed.

7. **Global Access Point**:
   - Singleton pattern provides a global access point to the instance, allowing easy access to its methods and properties from anywhere in the application without the need to pass references between objects.

It's important to note that while singleton pattern provides a convenient way to manage global state and resources, it can also introduce tight coupling and make unit testing more challenging. Therefore, it should be used judiciously and carefully evaluated based on the specific requirements of the application.

### 68. Do research on Factory, Builder, Observer, Decorator, static and dynamic Proxy pattern. what are their use cases, pros and cons
Sure, let's delve into each of these design patterns:

### Factory Pattern:
- **Use Cases**:
   - When the creation logic of an object is complex and should be encapsulated in a separate class.
   - When the client code needs to create objects without knowing the actual class of the object.

- **Pros**:
   - Encapsulates object creation logic, promoting loose coupling between client code and the created objects.
   - Provides a centralized point for managing object creation, making it easier to modify the creation process or introduce new object types.

- **Cons**:
   - Can introduce complexity if there are many different types of objects to be created, leading to a proliferation of factory classes.
   - Requires modifying the factory class if new types of objects need to be added.

### Builder Pattern:
- **Use Cases**:
   - When creating objects with many optional parameters or complex construction logic.
   - When the readability and maintainability of object creation code need to be improved.

- **Pros**:
   - Provides a fluent interface for constructing objects, improving readability and maintainability of object creation code.
   - Allows for the creation of immutable objects with a consistent state.

- **Cons**:
   - Can introduce verbosity if there are many optional parameters, leading to long builder methods.
   - Requires creating a separate builder class for each complex object, which may lead to code duplication.

### Observer Pattern:
- **Use Cases**:
   - When there is a one-to-many relationship between objects, and changes to one object need to be propagated to multiple dependent objects.
   - When decoupling the subject (observable) and observer objects is desired.

- **Pros**:
   - Promotes loose coupling between subject and observer objects, allowing for easier maintenance and modification of the system.
   - Supports dynamic registration and removal of observers, enabling flexible notification mechanisms.

- **Cons**:
   - Can lead to performance issues if there are many observers and frequent notifications, as each observer needs to be notified individually.
   - May introduce complexity if observers need to maintain state consistency or perform complex operations upon notification.

### Decorator Pattern:
- **Use Cases**:
   - When there is a need to add additional functionality to objects dynamically at runtime without modifying their structure.
   - When subclassing to extend functionality is impractical or leads to a combinatorial explosion of subclasses.

- **Pros**:
   - Allows for the flexible addition of new behaviors or responsibilities to objects, enhancing their functionality.
   - Promotes open-closed principle by allowing extension without modification of existing code.

- **Cons**:
   - Can lead to a large number of small decorator classes if there are many combinations of behaviors, which may become difficult to manage.
   - May introduce complexity and overhead due to the recursive nesting of decorators.

### Static Proxy Pattern:
- **Use Cases**:
   - When there is a need to control access to an object or add additional functionality without modifying its behavior.
   - When there is a need for centralized management of cross-cutting concerns such as logging, security, or transaction management.

- **Pros**:
   - Provides a simple way to control access to objects or add additional behavior, promoting separation of concerns.
   - Allows for transparent interception of method calls, enabling cross-cutting concerns to be applied uniformly.

- **Cons**:
   - Can introduce overhead and complexity if proxies need to be created for many objects or if there are many interceptable methods.
   - May lead to tight coupling between the proxy and the proxied object if not implemented carefully.

### Dynamic Proxy Pattern:
- **Use Cases**:
   - When there is a need to create proxies for objects dynamically at runtime.
   - When the structure of objects is not known at compile time or when creating proxies for remote objects.

- **Pros**:
   - Provides a flexible mechanism for creating proxies at runtime, allowing for dynamic interception of method calls.
   - Enables the implementation of cross-cutting concerns such as logging, security, or transaction management in a non-invasive manner.

- **Cons**:
   - Limited to interfaces, as dynamic proxies are generated at runtime using reflection.
   - Requires the use of additional libraries or frameworks such as Java's `Proxy` class or third-party libraries like CGLIB or ByteBuddy.
### 69. What is reflection
Reflection in Java is a mechanism that allows a program to examine or modify its own structure, behavior, and metadata at runtime. It provides a way to inspect classes, interfaces, fields, and methods dynamically, without knowing their names at compile time. With reflection, you can access and manipulate class members (fields, methods, constructors) and metadata (annotations, modifiers) programmatically, enabling powerful and flexible runtime behavior.

Here are some key features and use cases of reflection:

1. **Inspecting Classes and Members**: Reflection allows you to obtain information about classes, interfaces, fields, methods, and constructors at runtime. You can retrieve details such as names, types, annotations, modifiers, and access control levels of these elements.

2. **Dynamic Invocation of Methods**: Reflection enables you to invoke methods on objects dynamically at runtime, even if the method names are not known at compile time. You can invoke both static and instance methods, as well as methods with different parameter types.

3. **Creating Instances Dynamically**: Reflection provides a way to create new instances of classes and invoke constructors dynamically, allowing you to instantiate objects at runtime based on class names or types obtained dynamically.

4. **Accessing and Modifying Fields**: Reflection allows you to access and modify the values of fields (both static and instance) of objects dynamically, without knowing their names at compile time. You can read, write, and set the accessibility of fields using reflection.

5. **Dynamic Class Loading**: Reflection enables dynamic class loading and instantiation, allowing you to load classes and interfaces dynamically at runtime based on runtime conditions or configuration.

6. **Annotation Processing**: Reflection is commonly used in frameworks and libraries for annotation processing, where annotations are inspected and processed at runtime to provide additional functionality or behavior.

Reflection is a powerful and versatile feature of Java, but it should be used judiciously due to its potential performance overhead and complexity. It is often used in scenarios such as runtime code generation, dependency injection frameworks, serialization/deserialization libraries, testing frameworks, and dynamic proxies. However, excessive reliance on reflection can lead to less maintainable and harder-to-understand code, so it's essential to weigh the benefits and drawbacks carefully when using reflection in Java applications.

### 70. How does annotation work in spring
In Spring, annotations are used extensively to provide metadata and configuration information to the Spring Framework. Annotations help to simplify and streamline the configuration process, making it more intuitive and less error-prone. Here's how annotations work in Spring:

1. **Component Scanning**: Spring uses annotations such as `@Component`, `@Service`, `@Repository`, and `@Controller` to automatically detect and register Spring-managed components (beans) during the component scanning process. These annotations are used to mark classes as Spring-managed components, enabling automatic bean registration and dependency injection.

2. **Dependency Injection**: Annotations such as `@Autowired`, `@Inject`, and `@Resource` are used to inject dependencies into Spring-managed beans. These annotations allow you to specify dependencies directly on bean properties, constructor parameters, or setter methods, making it easier to wire beans together.

3. **Aspect-Oriented Programming (AOP)**: Spring uses annotations such as `@Aspect`, `@Before`, `@After`, `@Around`, and `@Pointcut` to define aspects and advice for applying cross-cutting concerns such as logging, security, and transaction management to application code. These annotations are used in conjunction with aspect-oriented programming (AOP) to modularize cross-cutting concerns and improve code maintainability.

4. **Transaction Management**: Annotations such as `@Transactional` are used to define transactional behavior for Spring-managed methods. By annotating methods with `@Transactional`, you can specify transactional semantics such as propagation, isolation, rollback rules, and transactional behavior for database operations.

5. **RESTful Web Services**: Spring MVC uses annotations such as `@Controller`, `@RequestMapping`, `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@RequestParam` to define RESTful web services and handle HTTP requests. These annotations are used to map request URLs to controller methods, extract request parameters, and specify HTTP request methods.

6. **Validation**: Spring uses annotations such as `@Valid` and `@Validated` to perform bean validation based on JSR-303/JSR-380 validation annotations such as `@NotNull`, `@NotBlank`, `@Size`, etc. These annotations are used to trigger validation of bean properties and method parameters before executing business logic.

7. **Configuration**: Annotations such as `@Configuration`, `@ComponentScan`, and `@Bean` are used to define Spring configuration classes and bean definitions. These annotations allow you to configure Spring beans, specify component scanning behavior, and define beans programmatically using Java configuration instead of XML.

Overall, annotations play a crucial role in simplifying configuration and development in Spring by providing a concise and expressive way to specify metadata, dependencies, aspects, transactions, and other aspects of application behavior. They enhance code readability, reduce boilerplate code, and promote best practices in application development.

### 71. What are HTTP status codes: 200/ 201/202/ 204/ 307/ 301/ 400/ 401/ 403/ 404/ 500, explain them by your own words
HTTP status codes are standardized numeric codes that are returned by a web server in response to a client's request to indicate the outcome of the request. Each status code represents a specific type of response, helping the client understand the result of their request and take appropriate action. Here's an explanation of the commonly used HTTP status codes:

1. **200 OK**: This status code indicates that the request was successful, and the server has fulfilled the client's request. The server returns this status code along with the requested resource or content.

2. **201 Created**: This status code indicates that the request has been fulfilled, and a new resource has been created as a result of the request. The server includes a `Location` header with the URI of the newly created resource.

3. **202 Accepted**: This status code indicates that the request has been accepted for processing by the server, but the processing has not been completed yet. It is used for asynchronous processing, where the final result may not be available immediately.

4. **204 No Content**: This status code indicates that the server successfully processed the request, but there is no content to return to the client. It is typically used for requests that do not require a response body, such as successful DELETE requests.

5. **301 Moved Permanently**: This status code indicates that the requested resource has been permanently moved to a new location, and the client should update its bookmarks or links to the new URL provided in the `Location` header.

6. **307 Temporary Redirect**: Similar to 301, this status code indicates that the requested resource has been temporarily moved to a new location. The client should use the new URL provided in the `Location` header for the current request only and continue to use the original URL for future requests.

7. **400 Bad Request**: This status code indicates that the server cannot process the client's request due to malformed syntax or invalid parameters. It is typically used when the client sends a request that cannot be understood by the server.

8. **401 Unauthorized**: This status code indicates that the client must authenticate itself before the server will process the request. It is used when the client needs to provide valid credentials (such as a username and password) to access the requested resource.

9. **403 Forbidden**: This status code indicates that the server understood the client's request but refuses to authorize access to the requested resource. It is typically used when the client does not have the necessary permissions to access the resource.

10. **404 Not Found**: This status code indicates that the server cannot find the requested resource. It is commonly used to indicate that the requested URL does not correspond to any known resource on the server.

11. **500 Internal Server Error**: This status code indicates that the server encountered an unexpected condition that prevented it from fulfilling the client's request. It is a generic error message used to indicate that something went wrong on the server side.

These are just a few of the many HTTP status codes defined by the HTTP specification. Each status code carries its own meaning and is used by servers to communicate the outcome of the request to clients in a standardized way.

### 72. What is HTTP
HTTP stands for Hypertext Transfer Protocol. It is an application-layer protocol that defines the format and rules for communication between web servers and clients (such as web browsers or mobile apps) over the internet. HTTP is the foundation of data communication on the World Wide Web and is used to request and transmit hypertext documents, such as web pages, images, videos, and other resources.

Here are some key points about HTTP:

1. **Client-Server Model**: HTTP follows a client-server model, where the client (such as a web browser) sends requests to a server (such as a web server) to retrieve resources, and the server responds with the requested resources or an error message.

2. **Stateless Protocol**: HTTP is stateless, meaning that each request from the client to the server is independent and does not contain any information about previous requests. This allows servers to handle requests in isolation without maintaining session state between requests.

3. **Request-Response Cycle**: The basic interaction in HTTP is the request-response cycle. The client sends an HTTP request to the server, specifying the method (such as GET, POST, PUT, DELETE) and the URL of the resource it wants to access. The server processes the request and sends back an HTTP response, which includes a status code indicating the outcome of the request and, optionally, the requested resource.

4. **Text-Based Protocol**: HTTP is a text-based protocol, meaning that its messages are human-readable and composed of plain text. Each HTTP message consists of a header section, which contains metadata about the request or response, followed by an optional message body, which contains the actual data being transmitted (such as HTML content or file data).

5. **Connectionless Protocol**: HTTP is connectionless, meaning that each request-response exchange occurs over a separate TCP connection. After sending a response, the server closes the connection, and the client must open a new connection for subsequent requests.

6. **Secure Version (HTTPS)**: HTTPS (Hypertext Transfer Protocol Secure) is a secure version of HTTP that uses encryption (such as SSL/TLS) to secure the communication between the client and server. It provides confidentiality, integrity, and authentication of the exchanged data, making it suitable for transmitting sensitive information over the internet.

Overall, HTTP is a fundamental protocol for communication on the World Wide Web, enabling the retrieval and transmission of hypertext documents and other resources between clients and servers.

### 73. What is get, post, put, delete, patch method
HTTP defines several request methods, also known as HTTP verbs, that indicate the action to be performed on a resource identified by a URL. Each method has its own semantics and is used for different purposes. Here's a brief overview of the commonly used HTTP methods:

1. **GET**: The GET method is used to request data from a specified resource. It retrieves the data identified by the URL without modifying it. GET requests should only be used for safe and idempotent operations, meaning that they should not have any side effects on the server and can be repeated multiple times without changing the outcome.

2. **POST**: The POST method is used to submit data to be processed to a specified resource. It sends data in the request body, typically used for creating new resources or submitting form data. Unlike GET, POST requests can have side effects on the server and are not idempotent, meaning that repeating the same request may result in different outcomes.

3. **PUT**: The PUT method is used to update or replace an existing resource with the data sent in the request body. It is idempotent, meaning that sending the same request multiple times will have the same effect as sending it once. PUT requests are typically used to update or create a resource at a specific URL.

4. **DELETE**: The DELETE method is used to delete a specified resource identified by the URL. It removes the resource from the server. Like PUT, DELETE requests are idempotent, meaning that sending the same request multiple times will have the same effect as sending it once.

5. **PATCH**: The PATCH method is used to apply partial modifications to a resource. It sends a set of changes to be applied to the resource in the request body. PATCH requests are typically used when you want to update only a portion of a resource without replacing it entirely. PATCH is not as widely used as GET, POST, PUT, and DELETE but can be useful in certain scenarios where partial updates are required.

These HTTP methods provide a standardized way for clients to interact with web servers and perform various operations on resources. Each method has its own semantics and is used in different scenarios depending on the desired action to be performed on the resource.

### 74. Post vs patch
The main difference between the POST and PATCH methods in HTTP lies in their intended use and the scope of the modifications they perform on resources:

1. **POST (Create)**:
   - The POST method is used to submit data to be processed to a specified resource.
   - It is typically used for creating new resources on the server.
   - POST requests often result in the creation of a new resource, with the server assigning a unique identifier (such as a new database entry) to the created resource.
   - POST requests may include a request body containing data to be processed or stored on the server.
   - POST requests are not idempotent, meaning that sending the same request multiple times may result in the creation of multiple resources or different outcomes.

2. **PATCH (Partial Update)**:
   - The PATCH method is used to apply partial modifications to a resource.
   - It is typically used when you want to update only a portion of a resource without replacing it entirely.
   - PATCH requests send a set of changes or updates to be applied to the resource in the request body.
   - PATCH requests are idempotent, meaning that sending the same request multiple times will have the same effect as sending it once.
   - Unlike PUT, which replaces the entire resource, PATCH updates only the specified fields or properties of the resource, leaving other fields unchanged.

In summary, while both POST and PATCH methods allow clients to modify resources on the server, POST is used for creating new resources, while PATCH is used for applying partial updates to existing resources. Additionally, PATCH requests are idempotent, whereas POST requests are not.

### 75. Post vs put
The main difference between the POST and PUT methods in HTTP lies in their intended use and the semantics of the operations they perform on resources:

1. **POST**:
   - The POST method is used to submit data to be processed to a specified resource.
   - It is typically used for creating new resources on the server or submitting data to be processed by a server-side script or application.
   - POST requests are not idempotent, meaning that sending the same request multiple times may result in the creation of multiple resources or different outcomes.
   - When a POST request is made to a resource, the server typically generates a new resource identifier (such as a new database entry) and returns it in the response, indicating that a new resource has been created.

2. **PUT**:
   - The PUT method is used to update or replace a specified resource with the data sent in the request body.
   - It is typically used for updating existing resources or creating new resources with a known identifier.
   - PUT requests are idempotent, meaning that sending the same request multiple times will have the same effect as sending it once.
   - When a PUT request is made to a resource, the server replaces the entire resource with the data sent in the request body. If the resource does not exist, it may be created with the specified data.
   - PUT requests are often used for updating or replacing entire resources, such as updating a user's profile information or uploading a new version of a file.

In summary, while both POST and PUT methods are used to modify resources on the server, POST is typically used for creating new resources or submitting data to be processed, while PUT is used for updating or replacing existing resources. Additionally, PUT requests are idempotent, whereas POST requests are not.

### 76. TCP 3 way handshaking
The TCP three-way handshake is the initial process that establishes a TCP connection between two devices (typically a client and a server) before they can exchange data. The handshake involves three steps:

1. **SYN (Synchronize)**:
   - The client sends a TCP segment with the SYN (synchronize) flag set to the server. This segment contains an initial sequence number (ISN) that the client chooses for the connection.
   - The SYN flag indicates to the server that the client wants to establish a connection and is ready to synchronize sequence numbers.

2. **SYN-ACK (Synchronize-Acknowledge)**:
   - Upon receiving the SYN segment from the client, the server responds with a TCP segment that has both the SYN and ACK (acknowledge) flags set.
   - The server selects its own initial sequence number (ISN) for the connection and acknowledges the client's ISN by incrementing it by one.
   - The SYN-ACK segment indicates to the client that the server has received the client's request to establish a connection and is also ready to synchronize sequence numbers.

3. **ACK (Acknowledge)**:
   - Finally, the client responds to the server's SYN-ACK segment by sending a TCP segment with the ACK flag set.
   - The client acknowledges the server's ISN by incrementing it by one, indicating that it has received the server's response.
   - At this point, the TCP connection is established between the client and the server, and they can begin to exchange data.

After the three-way handshake is completed, both the client and the server have synchronized sequence numbers and are ready to exchange data over the established TCP connection. The TCP connection remains open until either side decides to close it, typically using a four-way handshake to gracefully terminate the connection.

### 77. TCP vs UDP
TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) are two of the most common transport layer protocols used in computer networks. They differ in their design, features, and use cases:

1. **TCP (Transmission Control Protocol)**:
   - **Connection-Oriented**: TCP is a connection-oriented protocol, meaning that it establishes a reliable and ordered connection between the sender and receiver before data transfer begins. It ensures that data packets arrive at their destination in the correct order and without errors.
   - **Reliability**: TCP provides reliable delivery of data by using acknowledgments, retransmissions, and flow control mechanisms to ensure that all transmitted data packets are received successfully. It guarantees delivery and detects and retransmits lost or corrupted packets.
   - **Ordered Delivery**: TCP ensures that data packets are delivered to the receiver in the same order in which they were sent by the sender. It maintains sequencing and reorders out-of-order packets before delivering them to the application.
   - **Connection Management**: TCP uses a handshake mechanism (three-way handshake) to establish and terminate connections between devices. It provides features such as congestion control and error recovery to manage network congestion and packet loss.

2. **UDP (User Datagram Protocol)**:
   - **Connectionless**: UDP is a connectionless protocol, meaning that it does not establish a connection before data transfer. Each UDP packet is treated as an independent unit and is transmitted without any acknowledgment or error recovery mechanism.
   - **Unreliable**: UDP does not guarantee delivery or ordering of packets. It does not use acknowledgments or retransmissions, so there is no mechanism to detect or recover from lost or corrupted packets.
   - **Low Overhead**: UDP has lower overhead compared to TCP because it does not require connection establishment, acknowledgment, or sequencing mechanisms. This makes UDP faster and more lightweight, making it suitable for applications where speed is more important than reliability.
   - **Broadcast and Multicast Support**: UDP supports broadcast and multicast communication, allowing a single packet to be sent to multiple recipients simultaneously. This makes it suitable for applications such as streaming media, online gaming, and real-time communication where low latency and efficiency are critical.

In summary, TCP provides reliable, connection-oriented communication with guaranteed delivery and ordered transmission, making it suitable for applications such as web browsing, email, file transfer, and remote login. UDP, on the other hand, offers faster, connectionless communication with minimal overhead, making it suitable for applications such as real-time streaming, VoIP, DNS, and online gaming, where speed and low latency are more important than reliability.

### 78. [What's new in Java 8](#whats-new-in-java-8)
### 79. [What is the difference between JDK, JRE, and JVM?](#difference-between-jdk-jre-and-jvm)
### 80. How many types of memory areas are allocated by JVM?
The Java Virtual Machine (JVM) allocates memory for various purposes, and these memory areas can be categorized into several types. The main memory areas allocated by the JVM are as follows:

1. **Heap Memory**:
   - The heap memory is the runtime data area where objects are allocated. All Java objects, including instances of classes and arrays, are allocated on the heap.
   - The heap memory is shared among all threads of the Java application, and its size can be adjusted using JVM command-line options such as `-Xmx` and `-Xms`.
   - The heap memory is divided into two main generations: Young Generation and Old Generation (also known as Tenured Generation).

2. **Method Area (Non-Heap Memory)**:
   - The method area, also known as the permanent generation (PermGen) in older versions of the JVM, is a part of non-heap memory.
   - It stores class metadata, method information, static variables, and constant pool data. Each loaded class has its metadata stored in the method area.
   - In Java 8 and later versions, the permanent generation was replaced by the Metaspace, which is implemented as a native memory area outside of the Java heap.

3. **Stack Memory**:
   - Each thread in a Java application has its own private stack memory, which is used for storing method invocations, local variables, and partial results.
   - Stack memory is divided into two main areas: the Java stack and the native stack. The Java stack stores method frames, while the native stack is used for native methods and JNI (Java Native Interface) calls.
   - The size of stack memory is fixed for each thread and can be adjusted using JVM options such as `-Xss`.

4. **Program Counter (PC) Register**:
   - Each thread in a Java application has its own program counter (PC) register, which stores the address of the currently executing instruction.
   - The PC register is used for keeping track of the execution point within the current method.

5. **Native Method Stacks**:
   - Native method stacks are used for executing native methods, which are methods implemented in languages other than Java (e.g., C or C++).
   - Each thread has its own native method stack, which is separate from the Java stack.

These memory areas are managed by the JVM's memory management system, which includes components such as garbage collectors for reclaiming unused memory and memory allocators for allocating memory to objects and data structures. Proper understanding and management of these memory areas are essential for optimizing the performance and memory usage of Java applications.

### 81. What is classloader?
A classloader in Java is a subsystem of the Java Virtual Machine (JVM) responsible for loading classes and interfaces during the runtime of a Java program. It is an integral part of the Java runtime environment and plays a crucial role in the Java class loading mechanism.

### Key Responsibilities of a Classloader:

1. **Loading Classes**: The primary responsibility of a classloader is to locate and load Java classes and interfaces into the JVM. Classes can be loaded from various sources such as the file system, network, or custom repositories.

2. **Defining Class Identity**: Classloaders define the identity of a class by providing a unique namespace for loaded classes. Classes loaded by different classloaders are considered distinct, even if they have the same fully qualified name.

3. **Classpath Management**: Classloaders manage the classpath, which is a list of directories and JAR files containing Java class files. They search the classpath to locate and load classes as requested by the Java runtime.

4. **Dynamic Class Loading**: Classloaders support dynamic class loading, allowing classes to be loaded at runtime based on programmatic decisions or user input. This enables features such as plugin systems and dynamic code loading.

5. **Parent-Child Classloader Hierarchy**: Classloaders in Java form a hierarchical structure known as the classloader delegation model. Each classloader has a parent classloader, and when a class needs to be loaded, the JVM delegates the loading process to the parent classloader before attempting to load it itself. This hierarchy ensures that classes are loaded only once and prevents duplication.

### Types of Classloaders:

1. **Bootstrap Classloader**: The bootstrap classloader is responsible for loading core Java classes located in the `jre/lib` directory. It is the parent of all other classloaders and is implemented natively by the JVM.

2. **Extension Classloader**: The extension classloader loads classes from the `jre/lib/ext` directory or any other directory specified by the `java.ext.dirs` system property. It is the parent of the system classloader.

3. **System Classloader (Application Classloader)**: The system classloader loads classes from the classpath specified by the `java.class.path` system property. It is responsible for loading application classes and is the parent of any custom classloaders created by the application.

4. **Custom Classloaders**: Developers can create custom classloaders by extending the `java.lang.ClassLoader` class. Custom classloaders are used to implement advanced classloading strategies, such as loading classes from non-standard sources or implementing class versioning schemes.

In summary, classloaders are essential components of the Java runtime environment that handle the loading, defining, and management of classes and interfaces during the execution of Java programs. They enable dynamic class loading, namespace isolation, and classpath management, contributing to the flexibility and extensibility of the Java platform.

### 82. What if I write static public void instead of public static void?
In Java, the order of modifiers and keywords matters, so writing `static public void` instead of `public static void` would still be valid syntax, but it is not the conventional or recommended way to declare a method signature.

The correct and conventional order for method modifiers in Java is:
1. Access modifiers (e.g., `public`, `protected`, `private`)
2. Static modifier (if applicable)
3. Return type
4. Method name
5. Parameter list

So, the recommended way to declare a method with a `public` access modifier and `static` keyword would be:
```java
public static void methodName() {
    // Method body
}
```

However, if you write `static public void methodName()`, the compiler would still interpret it correctly, as both modifiers are valid and can be placed in either order. It's just not the common convention in Java programming.

### 83. What is the default value of the local variables?
### 84. [What are the various access specifiers in Java?](#various-access-specifiers-in-java)
### 85. What is the static variable?
A static variable in Java is a class-level variable that is shared among all instances (objects) of the class. Unlike instance variables, which are unique to each instance of a class, static variables belong to the class itself and are shared by all instances of that class. They are also sometimes referred to as class variables.

Here are some key characteristics of static variables in Java:

1. **Shared Among Instances**: Static variables are shared among all instances (objects) of the class. This means that changes made to a static variable by one instance will be visible to all other instances of the class.

2. **Belongs to the Class**: Static variables belong to the class itself, rather than to any particular instance of the class. They are declared using the `static` keyword and are initialized only once, at the time the class is loaded into memory.

3. **Accessed Using Class Name**: Static variables are accessed using the class name followed by the dot operator (`.`) and the variable name. They can also be accessed directly within static methods of the class without the need for an instance.

4. **Common Usage**: Static variables are commonly used for values or properties that are shared across all instances of the class, such as constants, configuration settings, counters, or shared resources.

Here's an example of a class with a static variable:

```java
public class Counter {
    // Static variable to count the number of instances created
    private static int count = 0;

    // Constructor to increment the count each time an instance is created
    public Counter() {
        count++;
    }

    // Method to get the current count
    public static int getCount() {
        return count;
    }

    public static void main(String[] args) {
        // Creating instances of the Counter class
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();

        // Printing the count using the static method
        System.out.println("Number of instances created: " + Counter.getCount()); // Output: 3
    }
}
```

In this example, the `count` variable is declared as a static variable, and it is incremented each time a new instance of the `Counter` class is created. The `getCount()` method is also declared as static and is used to retrieve the current count of instances created.

### 86. What is the purpose of static methods and variables?
Static methods and variables serve various purposes in Java, providing functionality and behavior that is not tied to any specific instance of a class. Here are some common purposes of static methods and variables:

1. **Utility Methods**: Static methods can be used to define utility functions that perform common tasks and calculations without the need for an instance of the class. These utility methods can be invoked directly using the class name without creating an object.

2. **Factory Methods**: Static methods can serve as factory methods for creating instances of the class. Factory methods provide flexibility in object creation and can encapsulate complex instantiation logic.

3. **Accessing Class-Level Resources**: Static variables are used to define class-level resources that are shared among all instances of the class. They can represent constants, configuration settings, shared counters, or other data that is relevant to the entire class.

4. **Counting Instances**: Static variables can be used to keep track of the number of instances created for a class. This can be useful for implementing singleton patterns, managing resource allocation, or monitoring object usage.

5. **Improving Performance**: Static methods and variables can improve performance by avoiding the overhead of object creation and method invocation. Since static methods and variables are associated with the class itself, they can be accessed directly without the need for an instance, leading to faster execution.

6. **Organizing Code**: Static methods and variables can help organize code by grouping related functionality and data within a class. They provide a convenient way to encapsulate behavior that is not tied to any specific instance and can be accessed globally within the class or from other classes.

Overall, static methods and variables offer flexibility, performance improvements, and code organization benefits in Java programming, allowing developers to create efficient and modular code. However, it's important to use static members judiciously and understand their implications on object-oriented design and code maintainability.
### 87. What are the restrictions that are applied to the Java static methods?
Static methods in Java have certain restrictions and limitations compared to instance methods. Here are some of the key restrictions that apply to Java static methods:

1. **Access to Instance Variables**: Static methods cannot directly access instance variables or non-static methods of the class. They operate at the class level and do not have access to the `this` reference, which represents the current instance of the class.

2. **Use of Instance Methods**: Static methods cannot be overridden by subclass methods declared with the same signature. Subclasses can define static methods with the same signature, but they are not considered overrides.

3. **Access to `super` Keyword**: Static methods cannot use the `super` keyword to access superclass methods or variables. They can only access superclass static members directly using the class name.

4. **Use of `this` Keyword**: Static methods cannot use the `this` keyword to refer to the current instance of the class. Attempting to use `this` in a static context will result in a compilation error.

5. **Access to Non-Static Members**: Static methods cannot directly call or access non-static members (variables or methods) of the class without first creating an instance of the class. They can only access static members directly using the class name.

6. **Abstract Static Methods**: Static methods cannot be declared as abstract. Abstract methods must be implemented by subclasses, but static methods cannot be overridden and are associated with the class itself rather than instances of the class.

7. **Inheritance and Overriding**: While subclasses can define static methods with the same signature as superclass static methods, they are not considered overrides. Subclass static methods with the same signature as superclass static methods do not override them but rather hide them.

8. **Access Modifiers**: Static methods can have any access modifier (public, protected, default, or private), but they cannot be declared as abstract, final, synchronized, or native.

Overall, static methods in Java provide functionality that is associated with the class itself rather than with instances of the class. They have certain restrictions compared to instance methods, primarily related to their inability to access instance-specific members and behavior.


### 88. What is an object in java?
In Java, an object is a fundamental unit of object-oriented programming (OOP) that represents a real-world entity, concept, or abstraction within a software system. Objects in Java are instances of classes, which serve as blueprints or templates for creating objects. Each object has its own state (data) and behavior (methods), encapsulating both into a single entity.

Here are some key points about objects in Java:

1. **Instance of a Class**: An object is an instance of a class. A class defines the structure and behavior of objects of a particular type, specifying the attributes (fields or instance variables) and methods (functions) that objects of that class will have.

2. **Encapsulation**: Objects encapsulate their state (data) and behavior (methods) together, hiding the internal state and implementation details from the outside world. Encapsulation ensures that an object's state can only be accessed and modified through well-defined methods, providing control over access and modification.

3. **State**: An object's state is represented by its data fields, also known as instance variables. These variables hold the current values of the object's properties, which can change over time. The state of an object determines its behavior and interactions with other objects.

4. **Behavior**: An object's behavior is defined by its methods, which represent the actions or operations that the object can perform. Methods define the behavior of the object and can manipulate its state or perform other tasks.

5. **Instantiation**: Objects are created, or instantiated, using the `new` keyword followed by a constructor call. The constructor initializes the object's state and performs any necessary setup tasks. Once instantiated, objects can be used to invoke methods, access or modify data, and interact with other objects.

6. **Reference Variables**: Objects are accessed and manipulated through reference variables. A reference variable holds a reference (memory address) to the location of the object in memory, allowing the program to access and operate on the object. Multiple reference variables can refer to the same object.

Here's a simple example of creating and using an object in Java:

```java
// Define a class
class MyClass {
    // Instance variable
    int value;

    // Constructor
    public MyClass(int value) {
        this.value = value;
    }

    // Method
    public void display() {
        System.out.println("Value: " + value);
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an object of MyClass
        MyClass obj = new MyClass(10);

        // Access and invoke methods on the object
        obj.display(); // Output: Value: 10
    }
}
```

In this example, `obj` is an object of the `MyClass` class. It has a state (value) and behavior (display method), encapsulating both within a single entity.

### 89. What is the constructor?
A constructor in Java is a special type of method that is automatically invoked when an object of a class is created using the `new` keyword. The primary purpose of a constructor is to initialize the newly created object, setting its initial state and performing any necessary setup tasks. Constructors have the same name as the class and may have parameters to allow customization during object creation.

Here are some key points about constructors in Java:

1. **Initialization**: Constructors initialize the newly created object by setting its initial state, initializing its instance variables, and performing any necessary initialization tasks. They ensure that the object is in a valid and usable state upon creation.

2. **Same Name as Class**: Constructors have the same name as the class in which they are declared. This allows the Java compiler to recognize them as constructors and automatically invoke them when creating objects of the class.

3. **No Return Type**: Constructors do not have a return type, not even `void`. This distinguishes them from regular methods, which may have return types to return values.

4. **Parameterized Constructors**: Constructors can have parameters to allow customization of the object during creation. Parameterized constructors enable different instances of the class to be initialized with different values.

5. **Default Constructor**: If a class does not explicitly define any constructors, Java provides a default constructor automatically. The default constructor initializes the object with default values (e.g., `0` for numeric types, `null` for reference types).

6. **Overloading Constructors**: Like methods, constructors can be overloaded by defining multiple constructors with different parameter lists. This allows objects to be created with different sets of initial values.

7. **Invocation**: Constructors are automatically invoked when an object is created using the `new` keyword. The appropriate constructor is called based on the arguments provided during object creation.

Here's a simple example of a class with a constructor:

```java
class MyClass {
    int value;

    // Constructor with no parameters
    public MyClass() {
        value = 0; // Initialize value to 0
    }

    // Parameterized constructor
    public MyClass(int v) {
        value = v; // Initialize value to the provided parameter
    }
}

public class Main {
    public static void main(String[] args) {
        // Create objects using constructors
        MyClass obj1 = new MyClass(); // Calls the no-argument constructor
        MyClass obj2 = new MyClass(10); // Calls the parameterized constructor
    }
}
```

In this example, `MyClass` has two constructors: a no-argument constructor that initializes `value` to `0`, and a parameterized constructor that initializes `value` to the value provided as a parameter during object creation. These constructors are automatically invoked when objects `obj1` and `obj2` are created using the `new` keyword.

### 90. Is constructor inherited?
In Java, constructors are not inherited by subclasses. However, subclasses can call constructors of the superclass using the `super()` keyword to invoke a constructor from the superclass explicitly.

Here are some key points regarding inheritance and constructors in Java:

1. **Constructor Overriding**: Unlike methods, constructors cannot be overridden in Java. Each class, including subclasses, must define its own constructors. If a subclass does not explicitly define any constructors, it will implicitly inherit the no-argument constructor (default constructor) from its superclass.

2. **Superclass Constructors**: Subclasses can call constructors of the superclass using the `super()` keyword. This allows subclasses to initialize inherited fields and perform additional initialization tasks defined in the superclass constructors. The `super()` keyword must be the first statement in a subclass constructor if it is used.

3. **Default Constructor Inheritance**: If a class does not define any constructors explicitly, Java provides a default constructor automatically. Subclasses will inherit this default constructor from the superclass. However, if the superclass defines any constructors explicitly, the default constructor is not provided.

Here's an example to illustrate constructor inheritance and superclass constructor invocation in Java:

```java
class Superclass {
    int value;

    // Constructor with parameter
    public Superclass(int v) {
        value = v;
    }
}

class Subclass extends Superclass {
    // Constructor with parameter
    public Subclass(int v) {
        super(v); // Call superclass constructor explicitly
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an object of Subclass
        Subclass obj = new Subclass(10);

        // Access the inherited field from Superclass
        System.out.println("Value: " + obj.value); // Output: Value: 10
    }
}
```

In this example, `Subclass` inherits the constructor from `Superclass`, but it does not inherit the constructor implementation. Instead, `Subclass` defines its own constructor and explicitly calls the superclass constructor using `super(v)` to initialize the `value` field inherited from `Superclass`.

### 91. Can you make a constructor final?
No, it is not possible to make a constructor `final` in Java. The `final` keyword in Java is used to declare constants, prevent method overriding, and restrict class inheritance, but it cannot be applied to constructors.

When a method is declared as `final`, it means that it cannot be overridden by subclasses. However, constructors are not inherited, and they cannot be overridden in the same way that methods can. Each class, including subclasses, must define its own constructors.

Here's an example to illustrate that attempting to make a constructor `final` will result in a compilation error:

```java
class MyClass {
    // Compiler error: Modifier 'final' not allowed here
    public final MyClass() {
        // Constructor implementation
    }
}
```

In this example, attempting to declare the constructor of `MyClass` as `final` will result in a compilation error because constructors cannot be marked as `final`. If you need to prevent instantiation of a class or restrict subclassing, you can make the class itself `final`, but not its constructors.

### 92. Can we overload the constructors?
Yes, constructors in Java can be overloaded, which means that a class can have multiple constructors with different parameter lists. Overloading constructors allows for flexibility in object creation by providing multiple ways to initialize objects with different sets of initial values.

Here are some key points about constructor overloading in Java:

1. **Method Overloading**: Constructor overloading follows the same rules as method overloading in Java. Constructors are considered overloaded if they have a different number of parameters, different types of parameters, or both.

2. **Initialization Flexibility**: Overloading constructors allows developers to provide different ways to initialize objects based on different scenarios or requirements. This flexibility can improve the usability and convenience of the class.

3. **Constructor Chaining**: Overloaded constructors can call other constructors within the same class using the `this()` keyword to reuse initialization logic. This is known as constructor chaining and is commonly used to avoid code duplication and maintain consistency among constructors.

4. **Default Constructor**: If a class defines one or more constructors explicitly, Java does not provide a default constructor automatically. However, if a class does not define any constructors, Java provides a default constructor implicitly. This default constructor can also be overloaded.

Here's an example to illustrate constructor overloading in Java:

```java
class MyClass {
    int value;

    // Constructor with no parameters
    public MyClass() {
        value = 0; // Initialize value to 0
    }

    // Parameterized constructor
    public MyClass(int v) {
        value = v; // Initialize value to the provided parameter
    }

    // Another parameterized constructor
    public MyClass(int v1, int v2) {
        value = v1 + v2; // Initialize value to the sum of the two parameters
    }
}

public class Main {
    public static void main(String[] args) {
        // Create objects using different constructors
        MyClass obj1 = new MyClass();        // Calls the no-argument constructor
        MyClass obj2 = new MyClass(10);      // Calls the parameterized constructor with one argument
        MyClass obj3 = new MyClass(20, 30);  // Calls the parameterized constructor with two arguments
    }
}
```

In this example, the `MyClass` class defines multiple constructors: a no-argument constructor, a parameterized constructor with one parameter, and another parameterized constructor with two parameters. Each constructor provides a different way to initialize objects of the class based on the provided arguments.
### 93. Can we make constructors static?
No, constructors cannot be declared as static in Java. The `static` keyword is used to define static members of a class, such as static variables and static methods, but it cannot be applied to constructors.

Here are some reasons why constructors cannot be static in Java:

1. **Initialization Context**: Constructors are responsible for initializing the state of objects when they are created. Static members, on the other hand, belong to the class itself rather than to individual instances of the class. Making a constructor static would imply that it belongs to the class rather than to objects, which contradicts the purpose of constructors.

2. **Instance-specific Initialization**: Constructors are invoked during object creation and are used to initialize instance variables and perform instance-specific initialization tasks. Making a constructor static would mean that it is associated with the class rather than with individual instances, which would prevent it from accessing instance variables and performing instance-specific initialization.

3. **Static Initialization Blocks**: In Java, static initialization blocks (`static { ... }`) can be used to perform static initialization tasks for a class. These blocks are executed when the class is loaded into memory, before any objects of the class are created. Static initialization blocks provide a mechanism for performing class-level initialization tasks without the need for a constructor to be static.

Here's an example to illustrate that attempting to make a constructor static will result in a compilation error:

```java
class MyClass {
    // Compiler error: modifier 'static' not allowed here
    public static MyClass() {
        // Constructor implementation
    }
}
```

In this example, attempting to declare the constructor of `MyClass` as static will result in a compilation error because constructors cannot be marked as static. Constructors are inherently associated with objects and are used to initialize object state, which is not compatible with the concept of static members.
### 94. Can we override the static methods?
No, it is not possible to override static methods in Java. Static methods belong to the class itself rather than to individual instances of the class, and they are associated with the class's type rather than with any particular object. Therefore, the concept of overriding, which is based on polymorphism and dynamic method dispatch, does not apply to static methods.

Here are some key points regarding overriding static methods in Java:

1. **Inheritance and Polymorphism**: Overriding is a mechanism in object-oriented programming where a subclass provides a specific implementation for a method defined in its superclass. This allows subclasses to customize behavior while maintaining a common interface.

2. **Static Binding**: Static methods are bound at compile time using static binding or early binding. This means that the method to be invoked is determined by the type of reference variable used to invoke the method, rather than the type of the object it refers to. This is in contrast to dynamic binding, which is used for instance methods and allows method invocation to be determined at runtime based on the actual type of the object.

3. **Hiding Static Methods**: When a subclass declares a static method with the same signature as a static method in its superclass, it is not considered overriding. Instead, it is known as method hiding. The subclass's static method hides the superclass's static method, and the method invoked is determined by the reference type rather than the object type.

Here's an example to illustrate that attempting to override a static method will result in a method hiding instead of method overriding:

```java
class Superclass {
    static void staticMethod() {
        System.out.println("Static method in superclass");
    }
}

class Subclass extends Superclass {
    static void staticMethod() {
        System.out.println("Static method in subclass");
    }
}

public class Main {
    public static void main(String[] args) {
        Superclass obj = new Subclass();
        obj.staticMethod(); // Output: Static method in superclass
    }
}
```

In this example, `Subclass` defines a static method with the same signature as the static method in `Superclass`. When `staticMethod()` is invoked using a reference of type `Superclass`, it invokes the static method defined in `Superclass` due to static binding. This behavior demonstrates method hiding rather than method overriding.

### 95. What if the static modifier is removed from the signature of the main method?
If the `static` modifier is removed from the signature of the `main` method in Java, the program will still compile successfully, but it will not run as a standalone Java application.

In Java, the `main` method serves as the entry point of a standalone Java application. It must be declared with the `static` modifier to indicate that it belongs to the class itself rather than to any particular instance of the class. This allows the Java Virtual Machine (JVM) to invoke the `main` method without creating an instance of the class.

If the `static` modifier is removed from the `main` method signature, the method becomes an instance method rather than a static method. As a result, the JVM will not be able to invoke the `main` method without first creating an instance of the class. This violates the requirement for a standalone Java application to have a `main` method that can be invoked without an object instance.

Here's an example to illustrate what happens if the `static` modifier is removed from the `main` method:

```java
public class Main {
    // This will result in a compilation error if the static modifier is removed
    public void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

If you attempt to compile this code without the `static` modifier in the `main` method, you will encounter a compilation error similar to the following:

```
Error: Main method not found in class Main, please define the main method as:
   public static void main(String[] args)
```

This error message indicates that the JVM could not find the required `main` method with the correct signature (`public static void main(String[] args)`) in the class. Therefore, the program cannot run as a standalone Java application.

### 96. What is the difference between static (class) method and instance method?
Static (class) methods and instance methods are two types of methods in Java that serve different purposes and have different behaviors. Here's a comparison between static methods and instance methods:

1. **Definition**:
   - **Static Method**: A static method is associated with the class itself rather than with any specific instance of the class. It is declared using the `static` keyword and can be invoked using the class name without the need to create an object instance.
   - **Instance Method**: An instance method belongs to a specific instance of the class. It is declared without the `static` keyword and can be invoked only on an object instance of the class.

2. **Invocation**:
   - **Static Method**: Static methods can be invoked using the class name, e.g., `ClassName.methodName()`. They can also be invoked using object instances, but this is generally discouraged because it can be confusing.
   - **Instance Method**: Instance methods can only be invoked on object instances of the class, e.g., `objectName.methodName()`.

3. **Accessing Members**:
   - **Static Method**: Static methods cannot access instance variables or instance methods directly. They can only access static variables and other static methods within the same class.
   - **Instance Method**: Instance methods can access both static variables and instance variables, as well as other instance methods within the same class.

4. **Usage**:
   - **Static Method**: Static methods are commonly used for utility functions, helper methods, factory methods, and operations that do not require access to instance-specific data.
   - **Instance Method**: Instance methods are used to manipulate the state of individual objects, perform object-specific operations, and interact with instance variables.

5. **Memory Allocation**:
   - **Static Method**: Static methods are stored in the method area of the JVM's memory, along with other class-level data.
   - **Instance Method**: Instance methods are associated with each object instance and are stored in the heap memory along with the object's instance variables.

6. **Overriding**:
   - **Static Method**: Static methods cannot be overridden in Java. They are associated with the class itself rather than with object instances, so subclassing does not affect their behavior.
   - **Instance Method**: Instance methods can be overridden in subclasses to provide specific implementations. This supports polymorphism and dynamic method dispatch.

In summary, static methods are associated with the class itself and are used for operations that do not require access to instance-specific data. Instance methods, on the other hand, operate on individual object instances and can access both static and instance-specific data. The choice between static and instance methods depends on the specific requirements of the functionality being implemented.

### 97. Can we make the abstract methods static in Java?
No, it is not possible to declare abstract methods as static in Java. Abstract methods are inherently associated with instance-specific behavior and are meant to be implemented by subclasses to provide concrete implementations. Making an abstract method static would contradict its purpose and behavior.

Here are some reasons why abstract methods cannot be declared as static in Java:

1. **Instance-specific Behavior**: Abstract methods represent behavior that is specific to instances of a class. They are meant to be implemented by subclasses to provide concrete implementations tailored to individual objects. Making an abstract method static would imply that it is associated with the class itself rather than with object instances, which contradicts the concept of instance-specific behavior.

2. **Inheritance and Polymorphism**: Abstract methods support inheritance and polymorphism by allowing subclasses to provide specific implementations. Static methods, on the other hand, are associated with the class itself and cannot be overridden or inherited. Allowing abstract methods to be static would break this inheritance mechanism and undermine the polymorphic behavior of abstract methods.

3. **Compiler Error**: If you attempt to declare an abstract method as static in Java, the compiler will raise a compilation error, indicating that abstract methods cannot have the `static` modifier. This is because static methods and abstract methods serve different purposes and have incompatible behaviors.

Here's an example to illustrate that attempting to declare an abstract method as static will result in a compilation error:

```java
abstract class MyClass {
    // Compiler error: abstract method cannot have a static modifier
    public static abstract void myMethod();
}
```

In this example, attempting to declare the `myMethod()` method as both `abstract` and `static` will result in a compilation error because abstract methods cannot have the `static` modifier. Abstract methods are meant to be overridden by subclasses to provide concrete implementations, while static methods belong to the class itself and cannot be overridden.
### 98. Can we declare the static variables and methods in an abstract class?
Cross-platformness, also known as platform independence or platform neutrality, refers to the ability of software, applications, or systems to run and operate seamlessly across different computing platforms or environments without requiring modification or adaptation.

In the context of software development, computing platforms can include different operating systems (such as Windows, macOS, Linux), hardware architectures (such as x86, ARM), programming languages, runtime environments, or devices (such as desktop computers, mobile devices, embedded systems).

Achieving cross-platformness involves developing software in a way that abstracts away platform-specific dependencies and considerations, allowing the software to be executed on diverse platforms without modification. This often involves the use of cross-platform development frameworks, libraries, or programming languages that provide a level of abstraction from underlying platform differences.

The benefits of cross-platformness include:

1. **Wider Audience Reach**: Cross-platform software can reach a larger audience of users who use different platforms or devices, increasing the potential user base and market share.

2. **Reduced Development and Maintenance Costs**: By developing software that can run on multiple platforms, developers can save time and effort by avoiding the need to develop and maintain separate versions of the software for each platform.

3. **Consistent User Experience**: Cross-platform software provides a consistent user experience across different platforms, ensuring that users have similar functionality and features regardless of the platform they are using.

4. **Flexibility and Portability**: Cross-platform software can be easily ported or deployed to different platforms without significant modifications, providing flexibility and portability for users and developers.

5. **Future-Proofing**: Cross-platform software is less vulnerable to changes in the technology landscape, such as shifts in platform dominance or the introduction of new platforms, as it can adapt and run on different platforms.

Examples of cross-platform software include web applications (which can run on any web browser), Java applications (which can run on any platform with the Java Virtual Machine installed), and cross-platform mobile development frameworks like React Native and Xamarin (which allow developers to build mobile apps for multiple platforms using a single codebase).
### 99. What is cross-platformness?
Cross-platformness, also known as platform independence or platform neutrality, refers to the ability of software, applications, or systems to run and operate seamlessly across different computing platforms or environments without requiring modification or adaptation.

In the context of software development, computing platforms can include different operating systems (such as Windows, macOS, Linux), hardware architectures (such as x86, ARM), programming languages, runtime environments, or devices (such as desktop computers, mobile devices, embedded systems).

Achieving cross-platformness involves developing software in a way that abstracts away platform-specific dependencies and considerations, allowing the software to be executed on diverse platforms without modification. This often involves the use of cross-platform development frameworks, libraries, or programming languages that provide a level of abstraction from underlying platform differences.

The benefits of cross-platformness include:

1. **Wider Audience Reach**: Cross-platform software can reach a larger audience of users who use different platforms or devices, increasing the potential user base and market share.

2. **Reduced Development and Maintenance Costs**: By developing software that can run on multiple platforms, developers can save time and effort by avoiding the need to develop and maintain separate versions of the software for each platform.

3. **Consistent User Experience**: Cross-platform software provides a consistent user experience across different platforms, ensuring that users have similar functionality and features regardless of the platform they are using.

4. **Flexibility and Portability**: Cross-platform software can be easily ported or deployed to different platforms without significant modifications, providing flexibility and portability for users and developers.

5. **Future-Proofing**: Cross-platform software is less vulnerable to changes in the technology landscape, such as shifts in platform dominance or the introduction of new platforms, as it can adapt and run on different platforms.

Examples of cross-platform software include web applications (which can run on any web browser), Java applications (which can run on any platform with the Java Virtual Machine installed), and cross-platform mobile development frameworks like React Native and Xamarin (which allow developers to build mobile apps for multiple platforms using a single codebase).
### 100. What is bytecode?
Bytecode is a low-level, platform-independent representation of code that is generated by compilers and used as an intermediate step in the execution of programs. It is a set of instructions that are designed to be executed by a virtual machine rather than directly by the computer's hardware.

In the context of Java programming, bytecode is the compiled output of Java source code. When you compile a Java source file (.java file) using the Java compiler (javac), it generates bytecode files (.class files) containing instructions in a format that can be executed by the Java Virtual Machine (JVM).

Here are some key points about Java bytecode:

1. **Platform Independence**: Java bytecode is designed to be platform-independent, meaning that it can be executed on any system that has a compatible Java Virtual Machine (JVM) installed. This allows Java programs to be written once and run anywhere, without modification.

2. **Intermediary Representation**: Bytecode serves as an intermediary representation of code between the high-level source code and the low-level machine code executed by the hardware. It allows for easier portability and execution of programs across different platforms.

3. **Instructions**: Java bytecode instructions are typically simple and low-level operations, such as loading and storing values, arithmetic and logical operations, method invocation, object creation, and control flow (branching and looping). Each bytecode instruction corresponds to a specific operation performed by the JVM.

4. **Class Files**: Java bytecode is stored in files with the .class extension, known as class files. These files contain the compiled bytecode instructions for one or more Java classes. During execution, the JVM loads and interprets these class files, executing the bytecode instructions one by one.

5. **Execution by JVM**: When a Java program is executed, the JVM loads the class files containing the bytecode instructions, verifies their integrity and security, and then executes the instructions using a combination of interpretation and just-in-time (JIT) compilation techniques.

6. **Optimization**: Some JVM implementations perform optimizations on bytecode to improve performance, such as inlining methods, eliminating redundant code, and optimizing memory usage. This allows Java programs to achieve good performance despite being executed in a virtualized environment.

Overall, Java bytecode plays a crucial role in enabling the platform independence and portability of Java programs, allowing them to be executed on a wide range of devices and platforms that support the Java platform.